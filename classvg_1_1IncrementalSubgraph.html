<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.17"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>vg: vg::IncrementalSubgraph Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">vg
   </div>
   <div id="projectbrief">tools for working with variation graphs</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.17 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacevg.html">vg</a></li><li class="navelem"><a class="el" href="classvg_1_1IncrementalSubgraph.html">IncrementalSubgraph</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pri-methods">Private Member Functions</a> &#124;
<a href="#pri-attribs">Private Attributes</a> &#124;
<a href="classvg_1_1IncrementalSubgraph-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">vg::IncrementalSubgraph Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;incremental_subgraph.hpp&gt;</code></p>
<div class="dynheader">
Inheritance diagram for vg::IncrementalSubgraph:</div>
<div class="dyncontent">
 <div class="center">
  <img src="classvg_1_1IncrementalSubgraph.png" usemap="#vg::IncrementalSubgraph_map" alt=""/>
  <map id="vg::IncrementalSubgraph_map" name="vg::IncrementalSubgraph_map">
<area href="classhandlegraph_1_1ExpandingOverlayGraph.html" alt="handlegraph::ExpandingOverlayGraph" shape="rect" coords="0,56,229,80"/>
<area href="classhandlegraph_1_1HandleGraph.html" alt="handlegraph::HandleGraph" shape="rect" coords="0,0,229,24"/>
  </map>
</div></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structvg_1_1IncrementalSubgraph_1_1FCmp.html">FCmp</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structvg_1_1IncrementalSubgraph_1_1IterFCmp.html">IterFCmp</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:ab942f4d62b91144afce73896b8004609"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1IncrementalSubgraph.html#ab942f4d62b91144afce73896b8004609">IncrementalSubgraph</a> (const <a class="el" href="classhandlegraph_1_1HandleGraph.html">HandleGraph</a> &amp;<a class="el" href="classvg_1_1IncrementalSubgraph.html#a45a1fbda6452cbdade4d40bc4dab539c">graph</a>, const <a class="el" href="namespacevg.html#a8232142f432c4dd8e7cfe96e1f50e039">pos_t</a> &amp;starting_position, bool <a class="el" href="classvg_1_1IncrementalSubgraph.html#a8b93ae511b47d189bdcf996d88f04f9d">extract_left</a>, int64_t <a class="el" href="classvg_1_1IncrementalSubgraph.html#a06d0598eae084de70fa40ed859ce9704">max_distance</a>=numeric_limits&lt; int64_t &gt;::max(), size_t <a class="el" href="classvg_1_1IncrementalSubgraph.html#af136b632b259faac2edc944a06b97011">frontier_copy_limit</a>=numeric_limits&lt; size_t &gt;::max(), size_t <a class="el" href="classvg_1_1IncrementalSubgraph.html#a37038271292f8c25f63b9d3e8400d13e">max_num_nodes</a>=numeric_limits&lt; size_t &gt;::max())</td></tr>
<tr class="separator:ab942f4d62b91144afce73896b8004609"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4c8f5a87dfcf68630d645a9469e75837"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1IncrementalSubgraph.html#a4c8f5a87dfcf68630d645a9469e75837">IncrementalSubgraph</a> ()=default</td></tr>
<tr class="memdesc:a4c8f5a87dfcf68630d645a9469e75837"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default constructor &ndash; not actually functional.  <a href="classvg_1_1IncrementalSubgraph.html#a4c8f5a87dfcf68630d645a9469e75837">More...</a><br /></td></tr>
<tr class="separator:a4c8f5a87dfcf68630d645a9469e75837"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a330ad1c9229ac053777528cb79efad3e"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1IncrementalSubgraph.html#a330ad1c9229ac053777528cb79efad3e">~IncrementalSubgraph</a> ()</td></tr>
<tr class="memdesc:a330ad1c9229ac053777528cb79efad3e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default destructor.  <a href="classvg_1_1IncrementalSubgraph.html#a330ad1c9229ac053777528cb79efad3e">More...</a><br /></td></tr>
<tr class="separator:a330ad1c9229ac053777528cb79efad3e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ada07715a97931d98157e8fc5aba697a9"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1IncrementalSubgraph.html#ada07715a97931d98157e8fc5aba697a9">is_extendable</a> () const</td></tr>
<tr class="memdesc:ada07715a97931d98157e8fc5aba697a9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specialized interface.  <a href="classvg_1_1IncrementalSubgraph.html#ada07715a97931d98157e8fc5aba697a9">More...</a><br /></td></tr>
<tr class="separator:ada07715a97931d98157e8fc5aba697a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a35e5051258b792c91da00cc0810ed178"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structhandlegraph_1_1handle__t.html">handle_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1IncrementalSubgraph.html#a35e5051258b792c91da00cc0810ed178">extend</a> ()</td></tr>
<tr class="memdesc:a35e5051258b792c91da00cc0810ed178"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extract an additional node.  <a href="classvg_1_1IncrementalSubgraph.html#a35e5051258b792c91da00cc0810ed178">More...</a><br /></td></tr>
<tr class="separator:a35e5051258b792c91da00cc0810ed178"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afe160f21d5b4a7964c1bceef47ca54a4"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1IncrementalSubgraph.html#afe160f21d5b4a7964c1bceef47ca54a4">order_of</a> (const <a class="el" href="structhandlegraph_1_1handle__t.html">handle_t</a> &amp;handle) const</td></tr>
<tr class="memdesc:afe160f21d5b4a7964c1bceef47ca54a4"><td class="mdescLeft">&#160;</td><td class="mdescRight">The order of a node in a topological order of the extracted graph.  <a href="classvg_1_1IncrementalSubgraph.html#afe160f21d5b4a7964c1bceef47ca54a4">More...</a><br /></td></tr>
<tr class="separator:afe160f21d5b4a7964c1bceef47ca54a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8c2059a01cfda921bd8c5f91bd3763c7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structhandlegraph_1_1handle__t.html">handle_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1IncrementalSubgraph.html#a8c2059a01cfda921bd8c5f91bd3763c7">handle_at_order</a> (size_t i) const</td></tr>
<tr class="memdesc:a8c2059a01cfda921bd8c5f91bd3763c7"><td class="mdescLeft">&#160;</td><td class="mdescRight">The node at a given position in the topological order.  <a href="classvg_1_1IncrementalSubgraph.html#a8c2059a01cfda921bd8c5f91bd3763c7">More...</a><br /></td></tr>
<tr class="separator:a8c2059a01cfda921bd8c5f91bd3763c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab859980ced41bcd382cd5961ff3b8475"><td class="memItemLeft" align="right" valign="top">int64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1IncrementalSubgraph.html#ab859980ced41bcd382cd5961ff3b8475">min_distance_from_start</a> (const <a class="el" href="structhandlegraph_1_1handle__t.html">handle_t</a> &amp;handle) const</td></tr>
<tr class="memdesc:ab859980ced41bcd382cd5961ff3b8475"><td class="mdescLeft">&#160;</td><td class="mdescRight">The minimum distance from the start position.  <a href="classvg_1_1IncrementalSubgraph.html#ab859980ced41bcd382cd5961ff3b8475">More...</a><br /></td></tr>
<tr class="separator:ab859980ced41bcd382cd5961ff3b8475"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0d573babd81fa2d0c209c75afec6c91d"><td class="memItemLeft" align="right" valign="top">int64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1IncrementalSubgraph.html#a0d573babd81fa2d0c209c75afec6c91d">max_distance_from_start</a> (const <a class="el" href="structhandlegraph_1_1handle__t.html">handle_t</a> &amp;handle) const</td></tr>
<tr class="memdesc:a0d573babd81fa2d0c209c75afec6c91d"><td class="mdescLeft">&#160;</td><td class="mdescRight">The maximum distance from the start position.  <a href="classvg_1_1IncrementalSubgraph.html#a0d573babd81fa2d0c209c75afec6c91d">More...</a><br /></td></tr>
<tr class="separator:a0d573babd81fa2d0c209c75afec6c91d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a91bb045370337f4f91aea10c14fdca95"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1IncrementalSubgraph.html#a91bb045370337f4f91aea10c14fdca95">extracting_left</a> () const</td></tr>
<tr class="memdesc:a91bb045370337f4f91aea10c14fdca95"><td class="mdescLeft">&#160;</td><td class="mdescRight">Are we doing extraction left or right?  <a href="classvg_1_1IncrementalSubgraph.html#a91bb045370337f4f91aea10c14fdca95">More...</a><br /></td></tr>
<tr class="separator:a91bb045370337f4f91aea10c14fdca95"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a29fe9b69774ab975e3b6fe15900d1c9e"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1IncrementalSubgraph.html#a29fe9b69774ab975e3b6fe15900d1c9e">has_node</a> (<a class="el" href="namespacevg.html#afaa15fd8bdfd688d48561e1b12aee821">id_t</a> node_id) const</td></tr>
<tr class="memdesc:a29fe9b69774ab975e3b6fe15900d1c9e"><td class="mdescLeft">&#160;</td><td class="mdescRight">HandleGraph interface.  <a href="classvg_1_1IncrementalSubgraph.html#a29fe9b69774ab975e3b6fe15900d1c9e">More...</a><br /></td></tr>
<tr class="separator:a29fe9b69774ab975e3b6fe15900d1c9e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac2d018cb5a59b4f43e24a4f30643e0f1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structhandlegraph_1_1handle__t.html">handle_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1IncrementalSubgraph.html#ac2d018cb5a59b4f43e24a4f30643e0f1">get_handle</a> (const <a class="el" href="namespacevg.html#afaa15fd8bdfd688d48561e1b12aee821">id_t</a> &amp;node_id, bool is_reverse=false) const</td></tr>
<tr class="memdesc:ac2d018cb5a59b4f43e24a4f30643e0f1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Look up the handle for the node with the given ID in the given orientation.  <a href="classvg_1_1IncrementalSubgraph.html#ac2d018cb5a59b4f43e24a4f30643e0f1">More...</a><br /></td></tr>
<tr class="separator:ac2d018cb5a59b4f43e24a4f30643e0f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a825edf9eddd3fa6093f2045656ae98f1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacevg.html#afaa15fd8bdfd688d48561e1b12aee821">id_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1IncrementalSubgraph.html#a825edf9eddd3fa6093f2045656ae98f1">get_id</a> (const <a class="el" href="structhandlegraph_1_1handle__t.html">handle_t</a> &amp;handle) const</td></tr>
<tr class="memdesc:a825edf9eddd3fa6093f2045656ae98f1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the ID from a handle.  <a href="classvg_1_1IncrementalSubgraph.html#a825edf9eddd3fa6093f2045656ae98f1">More...</a><br /></td></tr>
<tr class="separator:a825edf9eddd3fa6093f2045656ae98f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad4282dc0e503dc17e3724a41dbb0462c"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1IncrementalSubgraph.html#ad4282dc0e503dc17e3724a41dbb0462c">get_is_reverse</a> (const <a class="el" href="structhandlegraph_1_1handle__t.html">handle_t</a> &amp;handle) const</td></tr>
<tr class="memdesc:ad4282dc0e503dc17e3724a41dbb0462c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the orientation of a handle.  <a href="classvg_1_1IncrementalSubgraph.html#ad4282dc0e503dc17e3724a41dbb0462c">More...</a><br /></td></tr>
<tr class="separator:ad4282dc0e503dc17e3724a41dbb0462c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1dad5cc9948fd536f67bdd2f40ef6765"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structhandlegraph_1_1handle__t.html">handle_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1IncrementalSubgraph.html#a1dad5cc9948fd536f67bdd2f40ef6765">flip</a> (const <a class="el" href="structhandlegraph_1_1handle__t.html">handle_t</a> &amp;handle) const</td></tr>
<tr class="memdesc:a1dad5cc9948fd536f67bdd2f40ef6765"><td class="mdescLeft">&#160;</td><td class="mdescRight">Invert the orientation of a handle (potentially without getting its ID)  <a href="classvg_1_1IncrementalSubgraph.html#a1dad5cc9948fd536f67bdd2f40ef6765">More...</a><br /></td></tr>
<tr class="separator:a1dad5cc9948fd536f67bdd2f40ef6765"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a84ee16f64d60195d6ead2a57933af720"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1IncrementalSubgraph.html#a84ee16f64d60195d6ead2a57933af720">get_length</a> (const <a class="el" href="structhandlegraph_1_1handle__t.html">handle_t</a> &amp;handle) const</td></tr>
<tr class="memdesc:a84ee16f64d60195d6ead2a57933af720"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the length of a node.  <a href="classvg_1_1IncrementalSubgraph.html#a84ee16f64d60195d6ead2a57933af720">More...</a><br /></td></tr>
<tr class="separator:a84ee16f64d60195d6ead2a57933af720"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a61eef0cd10c65efae0cac12816084bb2"><td class="memItemLeft" align="right" valign="top">string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1IncrementalSubgraph.html#a61eef0cd10c65efae0cac12816084bb2">get_sequence</a> (const <a class="el" href="structhandlegraph_1_1handle__t.html">handle_t</a> &amp;handle) const</td></tr>
<tr class="separator:a61eef0cd10c65efae0cac12816084bb2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae130a9900ded50f9e69b24d5201bfcfc"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1IncrementalSubgraph.html#ae130a9900ded50f9e69b24d5201bfcfc">follow_edges_impl</a> (const <a class="el" href="structhandlegraph_1_1handle__t.html">handle_t</a> &amp;handle, bool go_left, const function&lt; bool(const <a class="el" href="structhandlegraph_1_1handle__t.html">handle_t</a> &amp;)&gt; &amp;iteratee) const</td></tr>
<tr class="separator:ae130a9900ded50f9e69b24d5201bfcfc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aabc1cb22610d6c41a79dc91617f785c1"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1IncrementalSubgraph.html#aabc1cb22610d6c41a79dc91617f785c1">for_each_handle_impl</a> (const function&lt; bool(const <a class="el" href="structhandlegraph_1_1handle__t.html">handle_t</a> &amp;)&gt; &amp;iteratee, bool parallel=false) const</td></tr>
<tr class="separator:aabc1cb22610d6c41a79dc91617f785c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a076dbda3b4b724157cad61f5f7b76b2b"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1IncrementalSubgraph.html#a076dbda3b4b724157cad61f5f7b76b2b">get_node_count</a> () const</td></tr>
<tr class="memdesc:a076dbda3b4b724157cad61f5f7b76b2b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the number of nodes in the graph.  <a href="classvg_1_1IncrementalSubgraph.html#a076dbda3b4b724157cad61f5f7b76b2b">More...</a><br /></td></tr>
<tr class="separator:a076dbda3b4b724157cad61f5f7b76b2b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2d34ac8b129c82511c38f267644918d5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacevg.html#afaa15fd8bdfd688d48561e1b12aee821">id_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1IncrementalSubgraph.html#a2d34ac8b129c82511c38f267644918d5">min_node_id</a> () const</td></tr>
<tr class="separator:a2d34ac8b129c82511c38f267644918d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa92bb84a3ea785a09c814932ae56a5a8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacevg.html#afaa15fd8bdfd688d48561e1b12aee821">id_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1IncrementalSubgraph.html#aa92bb84a3ea785a09c814932ae56a5a8">max_node_id</a> () const</td></tr>
<tr class="separator:aa92bb84a3ea785a09c814932ae56a5a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae3365d87d1cd6bfe12d3433197d06a85"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1IncrementalSubgraph.html#ae3365d87d1cd6bfe12d3433197d06a85">get_degree</a> (const <a class="el" href="structhandlegraph_1_1handle__t.html">handle_t</a> &amp;handle, bool go_left) const</td></tr>
<tr class="memdesc:ae3365d87d1cd6bfe12d3433197d06a85"><td class="mdescLeft">&#160;</td><td class="mdescRight">Optional HandleGraph interface.  <a href="classvg_1_1IncrementalSubgraph.html#ae3365d87d1cd6bfe12d3433197d06a85">More...</a><br /></td></tr>
<tr class="separator:ae3365d87d1cd6bfe12d3433197d06a85"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeab323f77d0363867dc60be6dafe73ce"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1IncrementalSubgraph.html#aeab323f77d0363867dc60be6dafe73ce">get_edge_count</a> () const</td></tr>
<tr class="separator:aeab323f77d0363867dc60be6dafe73ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6ff73a10a56b8116b7d07c32d3f3160a"><td class="memItemLeft" align="right" valign="top">char&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1IncrementalSubgraph.html#a6ff73a10a56b8116b7d07c32d3f3160a">get_base</a> (const <a class="el" href="structhandlegraph_1_1handle__t.html">handle_t</a> &amp;handle, size_t index) const</td></tr>
<tr class="separator:a6ff73a10a56b8116b7d07c32d3f3160a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a258698c76e4d96ecefd38505894f778b"><td class="memItemLeft" align="right" valign="top">string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1IncrementalSubgraph.html#a258698c76e4d96ecefd38505894f778b">get_subsequence</a> (const <a class="el" href="structhandlegraph_1_1handle__t.html">handle_t</a> &amp;handle, size_t index, size_t size) const</td></tr>
<tr class="separator:a258698c76e4d96ecefd38505894f778b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6b3e5f09eb2a9edb698eb08c55cc9486"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structhandlegraph_1_1handle__t.html">handle_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1IncrementalSubgraph.html#a6b3e5f09eb2a9edb698eb08c55cc9486">get_underlying_handle</a> (const <a class="el" href="structhandlegraph_1_1handle__t.html">handle_t</a> &amp;handle) const</td></tr>
<tr class="memdesc:a6b3e5f09eb2a9edb698eb08c55cc9486"><td class="mdescLeft">&#160;</td><td class="mdescRight">ExpandingOverlayGraph interface.  <a href="classvg_1_1IncrementalSubgraph.html#a6b3e5f09eb2a9edb698eb08c55cc9486">More...</a><br /></td></tr>
<tr class="separator:a6b3e5f09eb2a9edb698eb08c55cc9486"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_classhandlegraph_1_1ExpandingOverlayGraph"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_classhandlegraph_1_1ExpandingOverlayGraph')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="classhandlegraph_1_1ExpandingOverlayGraph.html">handlegraph::ExpandingOverlayGraph</a></td></tr>
<tr class="memitem:a9d7cac3cf3b289fe1980d0575e70be72 inherit pub_methods_classhandlegraph_1_1ExpandingOverlayGraph"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandlegraph_1_1ExpandingOverlayGraph.html#a9d7cac3cf3b289fe1980d0575e70be72">~ExpandingOverlayGraph</a> ()=default</td></tr>
<tr class="separator:a9d7cac3cf3b289fe1980d0575e70be72 inherit pub_methods_classhandlegraph_1_1ExpandingOverlayGraph"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_classhandlegraph_1_1HandleGraph"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_classhandlegraph_1_1HandleGraph')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="classhandlegraph_1_1HandleGraph.html">handlegraph::HandleGraph</a></td></tr>
<tr class="memitem:a24fb796441c9ad8c870fdb716a82b305 inherit pub_methods_classhandlegraph_1_1HandleGraph"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandlegraph_1_1HandleGraph.html#a24fb796441c9ad8c870fdb716a82b305">~HandleGraph</a> ()=default</td></tr>
<tr class="separator:a24fb796441c9ad8c870fdb716a82b305 inherit pub_methods_classhandlegraph_1_1HandleGraph"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4d21f30e62ad0b0c5919b2fe95e6f8aa inherit pub_methods_classhandlegraph_1_1HandleGraph"><td class="memTemplParams" colspan="2">template&lt;typename Iteratee &gt; </td></tr>
<tr class="memitem:a4d21f30e62ad0b0c5919b2fe95e6f8aa inherit pub_methods_classhandlegraph_1_1HandleGraph"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classhandlegraph_1_1HandleGraph.html#a4d21f30e62ad0b0c5919b2fe95e6f8aa">follow_edges</a> (const <a class="el" href="structhandlegraph_1_1handle__t.html">handle_t</a> &amp;handle, bool go_left, const Iteratee &amp;iteratee) const</td></tr>
<tr class="separator:a4d21f30e62ad0b0c5919b2fe95e6f8aa inherit pub_methods_classhandlegraph_1_1HandleGraph"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a928bdeabd328d357b538e30590164ab4 inherit pub_methods_classhandlegraph_1_1HandleGraph"><td class="memTemplParams" colspan="2">template&lt;typename Iteratee &gt; </td></tr>
<tr class="memitem:a928bdeabd328d357b538e30590164ab4 inherit pub_methods_classhandlegraph_1_1HandleGraph"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classhandlegraph_1_1HandleGraph.html#a928bdeabd328d357b538e30590164ab4">for_each_handle</a> (const Iteratee &amp;iteratee, bool parallel=false) const</td></tr>
<tr class="separator:a928bdeabd328d357b538e30590164ab4 inherit pub_methods_classhandlegraph_1_1HandleGraph"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a069448fbe58665b9ff531ad0b8c5af57 inherit pub_methods_classhandlegraph_1_1HandleGraph"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandlegraph_1_1HandleGraph.html#a069448fbe58665b9ff531ad0b8c5af57">has_edge</a> (const <a class="el" href="structhandlegraph_1_1handle__t.html">handle_t</a> &amp;left, const <a class="el" href="structhandlegraph_1_1handle__t.html">handle_t</a> &amp;right) const</td></tr>
<tr class="separator:a069448fbe58665b9ff531ad0b8c5af57 inherit pub_methods_classhandlegraph_1_1HandleGraph"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6171cdd6036c73623c96656f8b44fe9d inherit pub_methods_classhandlegraph_1_1HandleGraph"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandlegraph_1_1HandleGraph.html#a6171cdd6036c73623c96656f8b44fe9d">has_edge</a> (const <a class="el" href="namespacehandlegraph.html#a91452647367df9cfc96454c0cd07ce7b">edge_t</a> &amp;edge) const</td></tr>
<tr class="memdesc:a6171cdd6036c73623c96656f8b44fe9d inherit pub_methods_classhandlegraph_1_1HandleGraph"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convenient wrapper of has_edge for edge_t argument.  <a href="classhandlegraph_1_1HandleGraph.html#a6171cdd6036c73623c96656f8b44fe9d">More...</a><br /></td></tr>
<tr class="separator:a6171cdd6036c73623c96656f8b44fe9d inherit pub_methods_classhandlegraph_1_1HandleGraph"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4c98da99e0d32ebcc9fd31be4b779e29 inherit pub_methods_classhandlegraph_1_1HandleGraph"><td class="memItemLeft" align="right" valign="top">virtual size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandlegraph_1_1HandleGraph.html#a4c98da99e0d32ebcc9fd31be4b779e29">get_total_length</a> () const</td></tr>
<tr class="separator:a4c98da99e0d32ebcc9fd31be4b779e29 inherit pub_methods_classhandlegraph_1_1HandleGraph"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9e946bb4ed53f9423072955cdaab6386 inherit pub_methods_classhandlegraph_1_1HandleGraph"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structhandlegraph_1_1handle__t.html">handle_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandlegraph_1_1HandleGraph.html#a9e946bb4ed53f9423072955cdaab6386">forward</a> (const <a class="el" href="structhandlegraph_1_1handle__t.html">handle_t</a> &amp;handle) const</td></tr>
<tr class="memdesc:a9e946bb4ed53f9423072955cdaab6386 inherit pub_methods_classhandlegraph_1_1HandleGraph"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the locally forward version of a handle.  <a href="classhandlegraph_1_1HandleGraph.html#a9e946bb4ed53f9423072955cdaab6386">More...</a><br /></td></tr>
<tr class="separator:a9e946bb4ed53f9423072955cdaab6386 inherit pub_methods_classhandlegraph_1_1HandleGraph"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3766f1aca1cbdbf827f2a12aaf2078ec inherit pub_methods_classhandlegraph_1_1HandleGraph"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacehandlegraph.html#a91452647367df9cfc96454c0cd07ce7b">edge_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandlegraph_1_1HandleGraph.html#a3766f1aca1cbdbf827f2a12aaf2078ec">edge_handle</a> (const <a class="el" href="structhandlegraph_1_1handle__t.html">handle_t</a> &amp;left, const <a class="el" href="structhandlegraph_1_1handle__t.html">handle_t</a> &amp;right) const</td></tr>
<tr class="separator:a3766f1aca1cbdbf827f2a12aaf2078ec inherit pub_methods_classhandlegraph_1_1HandleGraph"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af167b0664299cfd4eac610f129fa5fee inherit pub_methods_classhandlegraph_1_1HandleGraph"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structhandlegraph_1_1handle__t.html">handle_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandlegraph_1_1HandleGraph.html#af167b0664299cfd4eac610f129fa5fee">traverse_edge_handle</a> (const <a class="el" href="namespacehandlegraph.html#a91452647367df9cfc96454c0cd07ce7b">edge_t</a> &amp;edge, const <a class="el" href="structhandlegraph_1_1handle__t.html">handle_t</a> &amp;left) const</td></tr>
<tr class="separator:af167b0664299cfd4eac610f129fa5fee inherit pub_methods_classhandlegraph_1_1HandleGraph"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a61570ded026f825d62ea7608a1e92349 inherit pub_methods_classhandlegraph_1_1HandleGraph"><td class="memTemplParams" colspan="2">template&lt;typename Iteratee &gt; </td></tr>
<tr class="memitem:a61570ded026f825d62ea7608a1e92349 inherit pub_methods_classhandlegraph_1_1HandleGraph"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classhandlegraph_1_1HandleGraph.html#a61570ded026f825d62ea7608a1e92349">for_each_edge</a> (const Iteratee &amp;iteratee, bool parallel=false) const</td></tr>
<tr class="separator:a61570ded026f825d62ea7608a1e92349 inherit pub_methods_classhandlegraph_1_1HandleGraph"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-methods"></a>
Private Member Functions</h2></td></tr>
<tr class="memitem:ab6537f375ee27409fee46bd4dfdcb1a3"><td class="memItemLeft" align="right" valign="top">pair&lt; size_t, size_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1IncrementalSubgraph.html#ab6537f375ee27409fee46bd4dfdcb1a3">underlying_interval</a> (size_t i) const</td></tr>
<tr class="separator:ab6537f375ee27409fee46bd4dfdcb1a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-attribs"></a>
Private Attributes</h2></td></tr>
<tr class="memitem:a8b93ae511b47d189bdcf996d88f04f9d"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1IncrementalSubgraph.html#a8b93ae511b47d189bdcf996d88f04f9d">extract_left</a></td></tr>
<tr class="memdesc:a8b93ae511b47d189bdcf996d88f04f9d"><td class="mdescLeft">&#160;</td><td class="mdescRight">direction we're extracting from the start pos  <a href="classvg_1_1IncrementalSubgraph.html#a8b93ae511b47d189bdcf996d88f04f9d">More...</a><br /></td></tr>
<tr class="separator:a8b93ae511b47d189bdcf996d88f04f9d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a06d0598eae084de70fa40ed859ce9704"><td class="memItemLeft" align="right" valign="top">int64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1IncrementalSubgraph.html#a06d0598eae084de70fa40ed859ce9704">max_distance</a></td></tr>
<tr class="memdesc:a06d0598eae084de70fa40ed859ce9704"><td class="mdescLeft">&#160;</td><td class="mdescRight">farthest distance we will travel from the start pos  <a href="classvg_1_1IncrementalSubgraph.html#a06d0598eae084de70fa40ed859ce9704">More...</a><br /></td></tr>
<tr class="separator:a06d0598eae084de70fa40ed859ce9704"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af136b632b259faac2edc944a06b97011"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1IncrementalSubgraph.html#af136b632b259faac2edc944a06b97011">frontier_copy_limit</a></td></tr>
<tr class="memdesc:af136b632b259faac2edc944a06b97011"><td class="mdescLeft">&#160;</td><td class="mdescRight">the maximum number of copies of a node we will allow in the frontier at a time  <a href="classvg_1_1IncrementalSubgraph.html#af136b632b259faac2edc944a06b97011">More...</a><br /></td></tr>
<tr class="separator:af136b632b259faac2edc944a06b97011"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a37038271292f8c25f63b9d3e8400d13e"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1IncrementalSubgraph.html#a37038271292f8c25f63b9d3e8400d13e">max_num_nodes</a></td></tr>
<tr class="separator:a37038271292f8c25f63b9d3e8400d13e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a07d9afa325ba5788ae4ad9cb4539d644"><td class="memItemLeft" align="right" valign="top">vector&lt; tuple&lt; <a class="el" href="structhandlegraph_1_1handle__t.html">handle_t</a>, vector&lt; size_t &gt;, vector&lt; size_t &gt;, int64_t, int64_t &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1IncrementalSubgraph.html#a07d9afa325ba5788ae4ad9cb4539d644">extracted</a></td></tr>
<tr class="memdesc:a07d9afa325ba5788ae4ad9cb4539d644"><td class="mdescLeft">&#160;</td><td class="mdescRight">records of (underlying handle, left edges, right edges, min distance, max distance)  <a href="classvg_1_1IncrementalSubgraph.html#a07d9afa325ba5788ae4ad9cb4539d644">More...</a><br /></td></tr>
<tr class="separator:a07d9afa325ba5788ae4ad9cb4539d644"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acfc80beeefec7f96a686a85db694985a"><td class="memItemLeft" align="right" valign="top">set&lt; tuple&lt; int64_t, <a class="el" href="structhandlegraph_1_1handle__t.html">handle_t</a>, unordered_set&lt; <a class="el" href="structhandlegraph_1_1handle__t.html">handle_t</a> &gt; *, vector&lt; size_t &gt; * &gt;, <a class="el" href="structvg_1_1IncrementalSubgraph_1_1FCmp.html">FCmp</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1IncrementalSubgraph.html#acfc80beeefec7f96a686a85db694985a">frontier</a></td></tr>
<tr class="separator:acfc80beeefec7f96a686a85db694985a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a877311143c9e9791fa85b29ae7a1351c"><td class="memItemLeft" align="right" valign="top">unordered_map&lt; <a class="el" href="structhandlegraph_1_1handle__t.html">handle_t</a>, unordered_map&lt; <a class="el" href="structhandlegraph_1_1handle__t.html">handle_t</a>, set&lt; decltype(<a class="el" href="classvg_1_1IncrementalSubgraph.html#acfc80beeefec7f96a686a85db694985a">frontier</a>)::iterator, <a class="el" href="structvg_1_1IncrementalSubgraph_1_1IterFCmp.html">IterFCmp</a> &gt; &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1IncrementalSubgraph.html#a877311143c9e9791fa85b29ae7a1351c">frontier_index</a></td></tr>
<tr class="separator:a877311143c9e9791fa85b29ae7a1351c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa5becc3ca659a557a83bff4de8643ff4"><td class="memItemLeft" align="right" valign="top">unordered_map&lt; <a class="el" href="structhandlegraph_1_1handle__t.html">handle_t</a>, size_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1IncrementalSubgraph.html#aa5becc3ca659a557a83bff4de8643ff4">frontier_count</a></td></tr>
<tr class="memdesc:aa5becc3ca659a557a83bff4de8643ff4"><td class="mdescLeft">&#160;</td><td class="mdescRight">the number of a given node there is currently in the frontier  <a href="classvg_1_1IncrementalSubgraph.html#aa5becc3ca659a557a83bff4de8643ff4">More...</a><br /></td></tr>
<tr class="separator:aa5becc3ca659a557a83bff4de8643ff4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a45a1fbda6452cbdade4d40bc4dab539c"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classhandlegraph_1_1HandleGraph.html">HandleGraph</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1IncrementalSubgraph.html#a45a1fbda6452cbdade4d40bc4dab539c">graph</a> = nullptr</td></tr>
<tr class="memdesc:a45a1fbda6452cbdade4d40bc4dab539c"><td class="mdescLeft">&#160;</td><td class="mdescRight">the underlying graph  <a href="classvg_1_1IncrementalSubgraph.html#a45a1fbda6452cbdade4d40bc4dab539c">More...</a><br /></td></tr>
<tr class="separator:a45a1fbda6452cbdade4d40bc4dab539c"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="inherited"></a>
Additional Inherited Members</h2></td></tr>
<tr class="inherit_header pro_methods_classhandlegraph_1_1HandleGraph"><td colspan="2" onclick="javascript:toggleInherit('pro_methods_classhandlegraph_1_1HandleGraph')"><img src="closed.png" alt="-"/>&#160;Protected Member Functions inherited from <a class="el" href="classhandlegraph_1_1HandleGraph.html">handlegraph::HandleGraph</a></td></tr>
<tr class="memitem:a89bbc118fe1e8e1acb162c14be33e8b5 inherit pro_methods_classhandlegraph_1_1HandleGraph"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandlegraph_1_1HandleGraph.html#a89bbc118fe1e8e1acb162c14be33e8b5">follow_edges_impl</a> (const <a class="el" href="structhandlegraph_1_1handle__t.html">handle_t</a> &amp;handle, bool go_left, const std::function&lt; bool(const <a class="el" href="structhandlegraph_1_1handle__t.html">handle_t</a> &amp;)&gt; &amp;iteratee) const =0</td></tr>
<tr class="separator:a89bbc118fe1e8e1acb162c14be33e8b5 inherit pro_methods_classhandlegraph_1_1HandleGraph"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af48ba081fcb810267dc50e3a3e7ad391 inherit pro_methods_classhandlegraph_1_1HandleGraph"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandlegraph_1_1HandleGraph.html#af48ba081fcb810267dc50e3a3e7ad391">for_each_handle_impl</a> (const std::function&lt; bool(const <a class="el" href="structhandlegraph_1_1handle__t.html">handle_t</a> &amp;)&gt; &amp;iteratee, bool parallel=false) const =0</td></tr>
<tr class="separator:af48ba081fcb810267dc50e3a3e7ad391 inherit pro_methods_classhandlegraph_1_1HandleGraph"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>A subgraph that is extracted, made single-stranded, and DAG-fied online on an as-needed basis from the parent graph. It is restricted to subgraphs that extend from a single position in the graph in one direction. </p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="ab942f4d62b91144afce73896b8004609"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab942f4d62b91144afce73896b8004609">&#9670;&nbsp;</a></span>IncrementalSubgraph() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">vg::IncrementalSubgraph::IncrementalSubgraph </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classhandlegraph_1_1HandleGraph.html">HandleGraph</a> &amp;&#160;</td>
          <td class="paramname"><em>graph</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacevg.html#a8232142f432c4dd8e7cfe96e1f50e039">pos_t</a> &amp;&#160;</td>
          <td class="paramname"><em>starting_position</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>extract_left</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>max_distance</em> = <code>numeric_limits&lt;int64_t&gt;::max()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>frontier_copy_limit</em> = <code>numeric_limits&lt;size_t&gt;::max()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>max_num_nodes</em> = <code>numeric_limits&lt;size_t&gt;::max()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Initialize the copy number limits how many times a cyce will be traversed before giving up on it (until encountering it again) </p>

</div>
</div>
<a id="a4c8f5a87dfcf68630d645a9469e75837"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4c8f5a87dfcf68630d645a9469e75837">&#9670;&nbsp;</a></span>IncrementalSubgraph() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">vg::IncrementalSubgraph::IncrementalSubgraph </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Default constructor &ndash; not actually functional. </p>

</div>
</div>
<a id="a330ad1c9229ac053777528cb79efad3e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a330ad1c9229ac053777528cb79efad3e">&#9670;&nbsp;</a></span>~IncrementalSubgraph()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">vg::IncrementalSubgraph::~IncrementalSubgraph </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Default destructor. </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a35e5051258b792c91da00cc0810ed178"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a35e5051258b792c91da00cc0810ed178">&#9670;&nbsp;</a></span>extend()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structhandlegraph_1_1handle__t.html">handle_t</a> vg::IncrementalSubgraph::extend </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Extract an additional node. </p>

</div>
</div>
<a id="a91bb045370337f4f91aea10c14fdca95"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a91bb045370337f4f91aea10c14fdca95">&#9670;&nbsp;</a></span>extracting_left()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool vg::IncrementalSubgraph::extracting_left </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Are we doing extraction left or right? </p>

</div>
</div>
<a id="a1dad5cc9948fd536f67bdd2f40ef6765"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1dad5cc9948fd536f67bdd2f40ef6765">&#9670;&nbsp;</a></span>flip()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structhandlegraph_1_1handle__t.html">handle_t</a> vg::IncrementalSubgraph::flip </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structhandlegraph_1_1handle__t.html">handle_t</a> &amp;&#160;</td>
          <td class="paramname"><em>handle</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Invert the orientation of a handle (potentially without getting its ID) </p>

<p>Implements <a class="el" href="classhandlegraph_1_1HandleGraph.html#aaa3f94ae7e884408ef6e8ca8fd45c7d7">handlegraph::HandleGraph</a>.</p>

</div>
</div>
<a id="ae130a9900ded50f9e69b24d5201bfcfc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae130a9900ded50f9e69b24d5201bfcfc">&#9670;&nbsp;</a></span>follow_edges_impl()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool vg::IncrementalSubgraph::follow_edges_impl </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structhandlegraph_1_1handle__t.html">handle_t</a> &amp;&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>go_left</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const function&lt; bool(const <a class="el" href="structhandlegraph_1_1handle__t.html">handle_t</a> &amp;)&gt; &amp;&#160;</td>
          <td class="paramname"><em>iteratee</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Loop over all the handles to next/previous (right/left) nodes. Passes them to a callback which returns false to stop iterating and true to continue. Returns true if we finished and false if we stopped early. </p>

</div>
</div>
<a id="aabc1cb22610d6c41a79dc91617f785c1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aabc1cb22610d6c41a79dc91617f785c1">&#9670;&nbsp;</a></span>for_each_handle_impl()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool vg::IncrementalSubgraph::for_each_handle_impl </td>
          <td>(</td>
          <td class="paramtype">const function&lt; bool(const <a class="el" href="structhandlegraph_1_1handle__t.html">handle_t</a> &amp;)&gt; &amp;&#160;</td>
          <td class="paramname"><em>iteratee</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>parallel</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Loop over all the nodes in the graph in their local forward orientations, in their internal stored order. Stop if the iteratee returns false. Can be told to run in parallel, in which case stopping after a false return value is on a best-effort basis and iteration order is not defined. </p>

</div>
</div>
<a id="a6ff73a10a56b8116b7d07c32d3f3160a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6ff73a10a56b8116b7d07c32d3f3160a">&#9670;&nbsp;</a></span>get_base()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">char vg::IncrementalSubgraph::get_base </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structhandlegraph_1_1handle__t.html">handle_t</a> &amp;&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>index</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns one base of a handle's sequence, in the orientation of the handle. </p>

<p>Reimplemented from <a class="el" href="classhandlegraph_1_1HandleGraph.html#a64d58c3e26e9e7954dd25c3eff7af521">handlegraph::HandleGraph</a>.</p>

</div>
</div>
<a id="ae3365d87d1cd6bfe12d3433197d06a85"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae3365d87d1cd6bfe12d3433197d06a85">&#9670;&nbsp;</a></span>get_degree()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t vg::IncrementalSubgraph::get_degree </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structhandlegraph_1_1handle__t.html">handle_t</a> &amp;&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>go_left</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Optional HandleGraph interface. </p>
<p>Get the number of edges on the right (go_left = false) or left (go_left = true) side of the given handle. The default implementation is O(n) in the number of edges returned, but graph implementations that track this information more efficiently can override this method. </p>

<p>Reimplemented from <a class="el" href="classhandlegraph_1_1HandleGraph.html#ab259e3aba0da47b0ef1c9b5e43c7d209">handlegraph::HandleGraph</a>.</p>

</div>
</div>
<a id="aeab323f77d0363867dc60be6dafe73ce"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeab323f77d0363867dc60be6dafe73ce">&#9670;&nbsp;</a></span>get_edge_count()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t vg::IncrementalSubgraph::get_edge_count </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return the total number of edges in the graph. If not overridden, counts them all in linear time. </p>

<p>Reimplemented from <a class="el" href="classhandlegraph_1_1HandleGraph.html#a20ff62014d7f0f0c01ada8a3d40a278d">handlegraph::HandleGraph</a>.</p>

</div>
</div>
<a id="ac2d018cb5a59b4f43e24a4f30643e0f1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac2d018cb5a59b4f43e24a4f30643e0f1">&#9670;&nbsp;</a></span>get_handle()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structhandlegraph_1_1handle__t.html">handle_t</a> vg::IncrementalSubgraph::get_handle </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacevg.html#afaa15fd8bdfd688d48561e1b12aee821">id_t</a> &amp;&#160;</td>
          <td class="paramname"><em>node_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>is_reverse</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Look up the handle for the node with the given ID in the given orientation. </p>

<p>Implements <a class="el" href="classhandlegraph_1_1HandleGraph.html#a6dd9d70931835f5c75518b23a780b744">handlegraph::HandleGraph</a>.</p>

</div>
</div>
<a id="a825edf9eddd3fa6093f2045656ae98f1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a825edf9eddd3fa6093f2045656ae98f1">&#9670;&nbsp;</a></span>get_id()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacevg.html#afaa15fd8bdfd688d48561e1b12aee821">id_t</a> vg::IncrementalSubgraph::get_id </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structhandlegraph_1_1handle__t.html">handle_t</a> &amp;&#160;</td>
          <td class="paramname"><em>handle</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the ID from a handle. </p>

<p>Implements <a class="el" href="classhandlegraph_1_1HandleGraph.html#adb7f6e144bf2a59679f7b2eddad934eb">handlegraph::HandleGraph</a>.</p>

</div>
</div>
<a id="ad4282dc0e503dc17e3724a41dbb0462c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad4282dc0e503dc17e3724a41dbb0462c">&#9670;&nbsp;</a></span>get_is_reverse()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool vg::IncrementalSubgraph::get_is_reverse </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structhandlegraph_1_1handle__t.html">handle_t</a> &amp;&#160;</td>
          <td class="paramname"><em>handle</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the orientation of a handle. </p>

<p>Implements <a class="el" href="classhandlegraph_1_1HandleGraph.html#a92773f90eb58f18adb9418a4440223c1">handlegraph::HandleGraph</a>.</p>

</div>
</div>
<a id="a84ee16f64d60195d6ead2a57933af720"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a84ee16f64d60195d6ead2a57933af720">&#9670;&nbsp;</a></span>get_length()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t vg::IncrementalSubgraph::get_length </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structhandlegraph_1_1handle__t.html">handle_t</a> &amp;&#160;</td>
          <td class="paramname"><em>handle</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the length of a node. </p>

<p>Implements <a class="el" href="classhandlegraph_1_1HandleGraph.html#a569ff35fb85c725b0b6b6933ed303e49">handlegraph::HandleGraph</a>.</p>

</div>
</div>
<a id="a076dbda3b4b724157cad61f5f7b76b2b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a076dbda3b4b724157cad61f5f7b76b2b">&#9670;&nbsp;</a></span>get_node_count()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t vg::IncrementalSubgraph::get_node_count </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the number of nodes in the graph. </p>

<p>Implements <a class="el" href="classhandlegraph_1_1HandleGraph.html#a9f95108e6c3f68f404fa93bd3306e4c6">handlegraph::HandleGraph</a>.</p>

</div>
</div>
<a id="a61eef0cd10c65efae0cac12816084bb2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a61eef0cd10c65efae0cac12816084bb2">&#9670;&nbsp;</a></span>get_sequence()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">string vg::IncrementalSubgraph::get_sequence </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structhandlegraph_1_1handle__t.html">handle_t</a> &amp;&#160;</td>
          <td class="paramname"><em>handle</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Get the sequence of a node, presented in the handle's local forward orientation. </p>

<p>Implements <a class="el" href="classhandlegraph_1_1HandleGraph.html#a8cc2ab8a1292e30ba5e167a823f66d92">handlegraph::HandleGraph</a>.</p>

</div>
</div>
<a id="a258698c76e4d96ecefd38505894f778b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a258698c76e4d96ecefd38505894f778b">&#9670;&nbsp;</a></span>get_subsequence()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">string vg::IncrementalSubgraph::get_subsequence </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structhandlegraph_1_1handle__t.html">handle_t</a> &amp;&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns a substring of a handle's sequence, in the orientation of the handle. If the indicated substring would extend beyond the end of the handle's sequence, the return value is truncated to the sequence's end. By default O(n) in the size of the handle's sequence, but can be overriden. </p>

<p>Reimplemented from <a class="el" href="classhandlegraph_1_1HandleGraph.html#a74c6fcda357516b1160996c63ed40d63">handlegraph::HandleGraph</a>.</p>

</div>
</div>
<a id="a6b3e5f09eb2a9edb698eb08c55cc9486"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6b3e5f09eb2a9edb698eb08c55cc9486">&#9670;&nbsp;</a></span>get_underlying_handle()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structhandlegraph_1_1handle__t.html">handle_t</a> vg::IncrementalSubgraph::get_underlying_handle </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structhandlegraph_1_1handle__t.html">handle_t</a> &amp;&#160;</td>
          <td class="paramname"><em>handle</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>ExpandingOverlayGraph interface. </p>
<p>Returns the handle in the underlying graph that corresponds to a handle in the overlay </p>

<p>Implements <a class="el" href="classhandlegraph_1_1ExpandingOverlayGraph.html#aacfa30b0166f91f1aa80f0fd566d2b65">handlegraph::ExpandingOverlayGraph</a>.</p>

</div>
</div>
<a id="a8c2059a01cfda921bd8c5f91bd3763c7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8c2059a01cfda921bd8c5f91bd3763c7">&#9670;&nbsp;</a></span>handle_at_order()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structhandlegraph_1_1handle__t.html">handle_t</a> vg::IncrementalSubgraph::handle_at_order </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The node at a given position in the topological order. </p>

</div>
</div>
<a id="a29fe9b69774ab975e3b6fe15900d1c9e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a29fe9b69774ab975e3b6fe15900d1c9e">&#9670;&nbsp;</a></span>has_node()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool vg::IncrementalSubgraph::has_node </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacevg.html#afaa15fd8bdfd688d48561e1b12aee821">id_t</a>&#160;</td>
          <td class="paramname"><em>node_id</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>HandleGraph interface. </p>
<p>Method to check if a node exists by ID </p>

<p>Implements <a class="el" href="classhandlegraph_1_1HandleGraph.html#a6e58a79001cd7d839ac1f1adaff34dfb">handlegraph::HandleGraph</a>.</p>

</div>
</div>
<a id="ada07715a97931d98157e8fc5aba697a9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ada07715a97931d98157e8fc5aba697a9">&#9670;&nbsp;</a></span>is_extendable()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool vg::IncrementalSubgraph::is_extendable </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Specialized interface. </p>
<p>True if there are additional nodes </p>

</div>
</div>
<a id="a0d573babd81fa2d0c209c75afec6c91d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0d573babd81fa2d0c209c75afec6c91d">&#9670;&nbsp;</a></span>max_distance_from_start()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int64_t vg::IncrementalSubgraph::max_distance_from_start </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structhandlegraph_1_1handle__t.html">handle_t</a> &amp;&#160;</td>
          <td class="paramname"><em>handle</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The maximum distance from the start position. </p>

</div>
</div>
<a id="aa92bb84a3ea785a09c814932ae56a5a8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa92bb84a3ea785a09c814932ae56a5a8">&#9670;&nbsp;</a></span>max_node_id()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacevg.html#afaa15fd8bdfd688d48561e1b12aee821">id_t</a> vg::IncrementalSubgraph::max_node_id </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return the largest ID in the graph, or some larger number if the largest ID is unavailable. Return value is unspecified if the graph is empty. </p>

<p>Implements <a class="el" href="classhandlegraph_1_1HandleGraph.html#a5a2e2b1ea6a29b3f4b34a6abcb6dbc50">handlegraph::HandleGraph</a>.</p>

</div>
</div>
<a id="ab859980ced41bcd382cd5961ff3b8475"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab859980ced41bcd382cd5961ff3b8475">&#9670;&nbsp;</a></span>min_distance_from_start()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int64_t vg::IncrementalSubgraph::min_distance_from_start </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structhandlegraph_1_1handle__t.html">handle_t</a> &amp;&#160;</td>
          <td class="paramname"><em>handle</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The minimum distance from the start position. </p>

</div>
</div>
<a id="a2d34ac8b129c82511c38f267644918d5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2d34ac8b129c82511c38f267644918d5">&#9670;&nbsp;</a></span>min_node_id()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacevg.html#afaa15fd8bdfd688d48561e1b12aee821">id_t</a> vg::IncrementalSubgraph::min_node_id </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return the smallest ID in the graph, or some smaller number if the smallest ID is unavailable. Return value is unspecified if the graph is empty. </p>

<p>Implements <a class="el" href="classhandlegraph_1_1HandleGraph.html#a85c52fe4b5f483504ed142d0ad94a969">handlegraph::HandleGraph</a>.</p>

</div>
</div>
<a id="afe160f21d5b4a7964c1bceef47ca54a4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afe160f21d5b4a7964c1bceef47ca54a4">&#9670;&nbsp;</a></span>order_of()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t vg::IncrementalSubgraph::order_of </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structhandlegraph_1_1handle__t.html">handle_t</a> &amp;&#160;</td>
          <td class="paramname"><em>handle</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The order of a node in a topological order of the extracted graph. </p>

</div>
</div>
<a id="ab6537f375ee27409fee46bd4dfdcb1a3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab6537f375ee27409fee46bd4dfdcb1a3">&#9670;&nbsp;</a></span>underlying_interval()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">pair&lt;size_t, size_t&gt; vg::IncrementalSubgraph::underlying_interval </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="a8b93ae511b47d189bdcf996d88f04f9d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8b93ae511b47d189bdcf996d88f04f9d">&#9670;&nbsp;</a></span>extract_left</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool vg::IncrementalSubgraph::extract_left</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>direction we're extracting from the start pos </p>

</div>
</div>
<a id="a07d9afa325ba5788ae4ad9cb4539d644"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a07d9afa325ba5788ae4ad9cb4539d644">&#9670;&nbsp;</a></span>extracted</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">vector&lt;tuple&lt;<a class="el" href="structhandlegraph_1_1handle__t.html">handle_t</a>, vector&lt;size_t&gt;, vector&lt;size_t&gt;, int64_t, int64_t&gt; &gt; vg::IncrementalSubgraph::extracted</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>records of (underlying handle, left edges, right edges, min distance, max distance) </p>

</div>
</div>
<a id="acfc80beeefec7f96a686a85db694985a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acfc80beeefec7f96a686a85db694985a">&#9670;&nbsp;</a></span>frontier</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">set&lt;tuple&lt;int64_t, <a class="el" href="structhandlegraph_1_1handle__t.html">handle_t</a>, unordered_set&lt;<a class="el" href="structhandlegraph_1_1handle__t.html">handle_t</a>&gt;*, vector&lt;size_t&gt;*&gt;, <a class="el" href="structvg_1_1IncrementalSubgraph_1_1FCmp.html">FCmp</a>&gt; vg::IncrementalSubgraph::frontier</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>records of (distance, node, unseen edges going into, seen edges going into). serves as an updateable priority queue for nodes that are adjacent to the extracted nodes the container classes are created on the heap so that we can do a remove-modify-replace update to frontier entries without deep-copying the containers </p>

</div>
</div>
<a id="af136b632b259faac2edc944a06b97011"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af136b632b259faac2edc944a06b97011">&#9670;&nbsp;</a></span>frontier_copy_limit</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t vg::IncrementalSubgraph::frontier_copy_limit</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>the maximum number of copies of a node we will allow in the frontier at a time </p>

</div>
</div>
<a id="aa5becc3ca659a557a83bff4de8643ff4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa5becc3ca659a557a83bff4de8643ff4">&#9670;&nbsp;</a></span>frontier_count</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unordered_map&lt;<a class="el" href="structhandlegraph_1_1handle__t.html">handle_t</a>, size_t&gt; vg::IncrementalSubgraph::frontier_count</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>the number of a given node there is currently in the frontier </p>

</div>
</div>
<a id="a877311143c9e9791fa85b29ae7a1351c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a877311143c9e9791fa85b29ae7a1351c">&#9670;&nbsp;</a></span>frontier_index</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unordered_map&lt;<a class="el" href="structhandlegraph_1_1handle__t.html">handle_t</a>, unordered_map&lt;<a class="el" href="structhandlegraph_1_1handle__t.html">handle_t</a>, set&lt;decltype(<a class="el" href="classvg_1_1IncrementalSubgraph.html#acfc80beeefec7f96a686a85db694985a">frontier</a>)::iterator, <a class="el" href="structvg_1_1IncrementalSubgraph_1_1IterFCmp.html">IterFCmp</a>&gt; &gt; &gt; vg::IncrementalSubgraph::frontier_index</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>provides random access into the frontier by handle, in the same order that the handles occur in the frontier. indexed by target node and then by predecessor node </p>

</div>
</div>
<a id="a45a1fbda6452cbdade4d40bc4dab539c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a45a1fbda6452cbdade4d40bc4dab539c">&#9670;&nbsp;</a></span>graph</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classhandlegraph_1_1HandleGraph.html">HandleGraph</a>* vg::IncrementalSubgraph::graph = nullptr</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>the underlying graph </p>

</div>
</div>
<a id="a06d0598eae084de70fa40ed859ce9704"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a06d0598eae084de70fa40ed859ce9704">&#9670;&nbsp;</a></span>max_distance</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int64_t vg::IncrementalSubgraph::max_distance</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>farthest distance we will travel from the start pos </p>

</div>
</div>
<a id="a37038271292f8c25f63b9d3e8400d13e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a37038271292f8c25f63b9d3e8400d13e">&#9670;&nbsp;</a></span>max_num_nodes</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t vg::IncrementalSubgraph::max_num_nodes</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>src/<a class="el" href="incremental__subgraph_8hpp.html">incremental_subgraph.hpp</a></li>
<li>src/<a class="el" href="incremental__subgraph_8cpp.html">incremental_subgraph.cpp</a></li>
</ul>
</div><!-- contents -->
<!-- HTML footer for doxygen 1.8.9.1-->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.17
</small></address>
</body>
</html>
