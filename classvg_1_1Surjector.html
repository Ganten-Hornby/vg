<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.17"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>vg: vg::Surjector Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">vg
   </div>
   <div id="projectbrief">tools for working with variation graphs</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.17 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacevg.html">vg</a></li><li class="navelem"><a class="el" href="classvg_1_1Surjector.html">Surjector</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-attribs">Public Attributes</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="#pro-static-methods">Static Protected Member Functions</a> &#124;
<a href="#pro-attribs">Protected Attributes</a> &#124;
<a href="classvg_1_1Surjector-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">vg::Surjector Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;surjector.hpp&gt;</code></p>
<div class="dynheader">
Inheritance diagram for vg::Surjector:</div>
<div class="dyncontent">
 <div class="center">
  <img src="classvg_1_1Surjector.png" usemap="#vg::Surjector_map" alt=""/>
  <map id="vg::Surjector_map" name="vg::Surjector_map">
<area href="classvg_1_1AlignerClient.html" alt="vg::AlignerClient" shape="rect" coords="0,0,105,24"/>
  </map>
</div></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:ad79d4e7acb0ed17759fd3e3301767b02"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1Surjector.html#ad79d4e7acb0ed17759fd3e3301767b02">path_chunk_t</a> = pair&lt; pair&lt; string::const_iterator, string::const_iterator &gt;, <a class="el" href="structvg_1_1Path.html">Path</a> &gt;</td></tr>
<tr class="memdesc:ad79d4e7acb0ed17759fd3e3301767b02"><td class="mdescLeft">&#160;</td><td class="mdescRight">a local type that represents a read interval matched to a portion of the alignment path  <a href="classvg_1_1Surjector.html#ad79d4e7acb0ed17759fd3e3301767b02">More...</a><br /></td></tr>
<tr class="separator:ad79d4e7acb0ed17759fd3e3301767b02"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a4b083231c3ae02e3e14c3efb2a72eb1d"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1Surjector.html#a4b083231c3ae02e3e14c3efb2a72eb1d">Surjector</a> (const <a class="el" href="classhandlegraph_1_1PathPositionHandleGraph.html">PathPositionHandleGraph</a> *<a class="el" href="classvg_1_1Surjector.html#a118010284d37b604a7bcd7eb8dd13537">graph</a>)</td></tr>
<tr class="separator:a4b083231c3ae02e3e14c3efb2a72eb1d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4e4e4c28b1313850e647f4d258a0ea82"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structvg_1_1Alignment.html">Alignment</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1Surjector.html#a4e4e4c28b1313850e647f4d258a0ea82">surject</a> (const <a class="el" href="structvg_1_1Alignment.html">Alignment</a> &amp;source, const unordered_set&lt; <a class="el" href="structhandlegraph_1_1path__handle__t.html">path_handle_t</a> &gt; &amp;paths, string &amp;path_name_out, int64_t &amp;path_pos_out, bool &amp;path_rev_out, bool allow_negative_scores=false, bool preserve_deletions=false) const</td></tr>
<tr class="separator:a4e4e4c28b1313850e647f4d258a0ea82"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a265cf90a6fb12021a70b87ec647c0867"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structvg_1_1Alignment.html">Alignment</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1Surjector.html#a265cf90a6fb12021a70b87ec647c0867">surject</a> (const <a class="el" href="structvg_1_1Alignment.html">Alignment</a> &amp;source, const unordered_set&lt; <a class="el" href="structhandlegraph_1_1path__handle__t.html">path_handle_t</a> &gt; &amp;paths, bool allow_negative_scores=false, bool preserve_deletions=false) const</td></tr>
<tr class="separator:a265cf90a6fb12021a70b87ec647c0867"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a80afa331fde9e8bcff66c4e87400217a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvg_1_1multipath__alignment__t.html">multipath_alignment_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1Surjector.html#a80afa331fde9e8bcff66c4e87400217a">surject</a> (const <a class="el" href="classvg_1_1multipath__alignment__t.html">multipath_alignment_t</a> &amp;source, const unordered_set&lt; <a class="el" href="structhandlegraph_1_1path__handle__t.html">path_handle_t</a> &gt; &amp;paths, string &amp;path_name_out, int64_t &amp;path_pos_out, bool &amp;path_rev_out, bool allow_negative_scores=false, bool preserve_deletions=false) const</td></tr>
<tr class="separator:a80afa331fde9e8bcff66c4e87400217a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_classvg_1_1AlignerClient"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_classvg_1_1AlignerClient')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="classvg_1_1AlignerClient.html">vg::AlignerClient</a></td></tr>
<tr class="memitem:ab74784d7320b1c33c7bf6e75259d4cea inherit pub_methods_classvg_1_1AlignerClient"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1AlignerClient.html#ab74784d7320b1c33c7bf6e75259d4cea">set_alignment_scores</a> (int8_t match, int8_t mismatch, int8_t gap_open, int8_t gap_extend, int8_t full_length_bonus)</td></tr>
<tr class="memdesc:ab74784d7320b1c33c7bf6e75259d4cea inherit pub_methods_classvg_1_1AlignerClient"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set all the aligner scoring parameters and create the stored aligner instances.  <a href="classvg_1_1AlignerClient.html#ab74784d7320b1c33c7bf6e75259d4cea">More...</a><br /></td></tr>
<tr class="separator:ab74784d7320b1c33c7bf6e75259d4cea inherit pub_methods_classvg_1_1AlignerClient"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5378f4e2b41a64a3bb51ba67e85d82bc inherit pub_methods_classvg_1_1AlignerClient"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1AlignerClient.html#a5378f4e2b41a64a3bb51ba67e85d82bc">set_alignment_scores</a> (std::istream &amp;matrix_stream, int8_t gap_open, int8_t gap_extend, int8_t full_length_bonus)</td></tr>
<tr class="separator:a5378f4e2b41a64a3bb51ba67e85d82bc inherit pub_methods_classvg_1_1AlignerClient"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa51310b7599508c91bcf5dd5cb25a175 inherit pub_methods_classvg_1_1AlignerClient"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1AlignerClient.html#aa51310b7599508c91bcf5dd5cb25a175">set_alignment_scores</a> (const int8_t *score_matrix, int8_t gap_open, int8_t gap_extend, int8_t full_length_bonus)</td></tr>
<tr class="separator:aa51310b7599508c91bcf5dd5cb25a175 inherit pub_methods_classvg_1_1AlignerClient"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-attribs"></a>
Public Attributes</h2></td></tr>
<tr class="memitem:a9046bb2c7267f996a6636518e2747b89"><td class="memItemLeft" align="right" valign="top">int64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1Surjector.html#a9046bb2c7267f996a6636518e2747b89">min_splice_length</a> = 20</td></tr>
<tr class="memdesc:a9046bb2c7267f996a6636518e2747b89"><td class="mdescLeft">&#160;</td><td class="mdescRight">the minimum length deletion that the spliced algorithm will interpret as a splice event  <a href="classvg_1_1Surjector.html#a9046bb2c7267f996a6636518e2747b89">More...</a><br /></td></tr>
<tr class="separator:a9046bb2c7267f996a6636518e2747b89"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ace7092128b309c97f00fc688d3311c14"><td class="memItemLeft" align="right" valign="top">int64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1Surjector.html#ace7092128b309c97f00fc688d3311c14">dominated_path_chunk_diff</a> = 10</td></tr>
<tr class="separator:ace7092128b309c97f00fc688d3311c14"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a77d7a865fffb0ebbc979ba8139f026c5"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1Surjector.html#a77d7a865fffb0ebbc979ba8139f026c5">max_subgraph_bases</a> = 100 * 1024</td></tr>
<tr class="memdesc:a77d7a865fffb0ebbc979ba8139f026c5"><td class="mdescLeft">&#160;</td><td class="mdescRight">How big of a graph in bp should we ever try to align against for realigning surjection?  <a href="classvg_1_1Surjector.html#a77d7a865fffb0ebbc979ba8139f026c5">More...</a><br /></td></tr>
<tr class="separator:a77d7a865fffb0ebbc979ba8139f026c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:affb3a5676516b7042d5c2d08734ea3c8"><td class="memItemLeft" align="right" valign="top">atomic_flag&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1Surjector.html#affb3a5676516b7042d5c2d08734ea3c8">warned_about_subgraph_size</a> = ATOMIC_FLAG_INIT</td></tr>
<tr class="memdesc:affb3a5676516b7042d5c2d08734ea3c8"><td class="mdescLeft">&#160;</td><td class="mdescRight">And have we complained about hitting it?  <a href="classvg_1_1Surjector.html#affb3a5676516b7042d5c2d08734ea3c8">More...</a><br /></td></tr>
<tr class="separator:affb3a5676516b7042d5c2d08734ea3c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af01db9677cefc7952fee698f8ee2b672"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1Surjector.html#af01db9677cefc7952fee698f8ee2b672">prune_suspicious_anchors</a> = false</td></tr>
<tr class="separator:af01db9677cefc7952fee698f8ee2b672"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a59034e11562bb0969c25defd215f166b"><td class="memItemLeft" align="right" valign="top">int64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1Surjector.html#a59034e11562bb0969c25defd215f166b">max_tail_anchor_prune</a> = 4</td></tr>
<tr class="separator:a59034e11562bb0969c25defd215f166b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1df336db06fea7951c960f71265d513d"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1Surjector.html#a1df336db06fea7951c960f71265d513d">low_complexity_p_value</a> = .001</td></tr>
<tr class="separator:a1df336db06fea7951c960f71265d513d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_attribs_classvg_1_1AlignerClient"><td colspan="2" onclick="javascript:toggleInherit('pub_attribs_classvg_1_1AlignerClient')"><img src="closed.png" alt="-"/>&#160;Public Attributes inherited from <a class="el" href="classvg_1_1AlignerClient.html">vg::AlignerClient</a></td></tr>
<tr class="memitem:a25db3953c246e94a7e08ef59fc31b82f inherit pub_attribs_classvg_1_1AlignerClient"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1AlignerClient.html#a25db3953c246e94a7e08ef59fc31b82f">adjust_alignments_for_base_quality</a> = false</td></tr>
<tr class="separator:a25db3953c246e94a7e08ef59fc31b82f inherit pub_attribs_classvg_1_1AlignerClient"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr class="memitem:ae96dd1321ff616a23b471e069e8597ea"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1Surjector.html#ae96dd1321ff616a23b471e069e8597ea">surject_internal</a> (const <a class="el" href="structvg_1_1Alignment.html">Alignment</a> *source_aln, const <a class="el" href="classvg_1_1multipath__alignment__t.html">multipath_alignment_t</a> *source_mp_aln, <a class="el" href="structvg_1_1Alignment.html">Alignment</a> *aln_out, <a class="el" href="classvg_1_1multipath__alignment__t.html">multipath_alignment_t</a> *mp_aln_out, const unordered_set&lt; <a class="el" href="structhandlegraph_1_1path__handle__t.html">path_handle_t</a> &gt; &amp;paths, string &amp;path_name_out, int64_t &amp;path_pos_out, bool &amp;path_rev_out, bool allow_negative_scores, bool preserve_deletions) const</td></tr>
<tr class="separator:ae96dd1321ff616a23b471e069e8597ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a14e1e1e6e00de6609e6c95826f53f3e3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structvg_1_1Alignment.html">Alignment</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1Surjector.html#a14e1e1e6e00de6609e6c95826f53f3e3">realigning_surject</a> (const <a class="el" href="classhandlegraph_1_1PathPositionHandleGraph.html">PathPositionHandleGraph</a> *<a class="el" href="classvg_1_1Surjector.html#a118010284d37b604a7bcd7eb8dd13537">graph</a>, const <a class="el" href="structvg_1_1Alignment.html">Alignment</a> &amp;source, const <a class="el" href="structhandlegraph_1_1path__handle__t.html">path_handle_t</a> &amp;path_handle, bool rev_strand, const vector&lt; <a class="el" href="classvg_1_1Surjector.html#ad79d4e7acb0ed17759fd3e3301767b02">path_chunk_t</a> &gt; &amp;path_chunks, pair&lt; <a class="el" href="structhandlegraph_1_1step__handle__t.html">step_handle_t</a>, <a class="el" href="structhandlegraph_1_1step__handle__t.html">step_handle_t</a> &gt; &amp;path_range_out, bool allow_negative_scores, bool preserve_N_alignments=false, bool preserve_tail_indel_anchors=false) const</td></tr>
<tr class="separator:a14e1e1e6e00de6609e6c95826f53f3e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8418e7a55b6b53456c80cbcf937406b5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvg_1_1multipath__alignment__t.html">multipath_alignment_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1Surjector.html#a8418e7a55b6b53456c80cbcf937406b5">spliced_surject</a> (const <a class="el" href="classhandlegraph_1_1PathPositionHandleGraph.html">PathPositionHandleGraph</a> *path_position_graph, const string &amp;src_sequence, const string &amp;src_quality, const int32_t src_mapping_quality, const <a class="el" href="structhandlegraph_1_1path__handle__t.html">path_handle_t</a> &amp;path_handle, bool rev_strand, vector&lt; <a class="el" href="classvg_1_1Surjector.html#ad79d4e7acb0ed17759fd3e3301767b02">path_chunk_t</a> &gt; &amp;path_chunks, vector&lt; pair&lt; <a class="el" href="structhandlegraph_1_1step__handle__t.html">step_handle_t</a>, <a class="el" href="structhandlegraph_1_1step__handle__t.html">step_handle_t</a> &gt;&gt; &amp;ref_chunks, vector&lt; tuple&lt; size_t, size_t, int32_t &gt;&gt; &amp;connections, pair&lt; <a class="el" href="structhandlegraph_1_1step__handle__t.html">step_handle_t</a>, <a class="el" href="structhandlegraph_1_1step__handle__t.html">step_handle_t</a> &gt; &amp;path_range_out, bool allow_negative_scores, bool deletions_as_splices) const</td></tr>
<tr class="separator:a8418e7a55b6b53456c80cbcf937406b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af4b7099431a6a5334141760cc8922281"><td class="memItemLeft" align="right" valign="top">unordered_map&lt; pair&lt; <a class="el" href="structhandlegraph_1_1path__handle__t.html">path_handle_t</a>, bool &gt;, pair&lt; vector&lt; <a class="el" href="classvg_1_1Surjector.html#ad79d4e7acb0ed17759fd3e3301767b02">path_chunk_t</a> &gt;, vector&lt; pair&lt; <a class="el" href="structhandlegraph_1_1step__handle__t.html">step_handle_t</a>, <a class="el" href="structhandlegraph_1_1step__handle__t.html">step_handle_t</a> &gt; &gt; &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1Surjector.html#af4b7099431a6a5334141760cc8922281">extract_overlapping_paths</a> (const <a class="el" href="classhandlegraph_1_1PathPositionHandleGraph.html">PathPositionHandleGraph</a> *<a class="el" href="classvg_1_1Surjector.html#a118010284d37b604a7bcd7eb8dd13537">graph</a>, const <a class="el" href="structvg_1_1Alignment.html">Alignment</a> &amp;source, const unordered_set&lt; <a class="el" href="structhandlegraph_1_1path__handle__t.html">path_handle_t</a> &gt; &amp;surjection_paths) const</td></tr>
<tr class="memdesc:af4b7099431a6a5334141760cc8922281"><td class="mdescLeft">&#160;</td><td class="mdescRight">get the chunks of the alignment path that follow the given reference paths  <a href="classvg_1_1Surjector.html#af4b7099431a6a5334141760cc8922281">More...</a><br /></td></tr>
<tr class="separator:af4b7099431a6a5334141760cc8922281"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adc4dbb4ce6f48d755c91e4931028c6d8"><td class="memItemLeft" align="right" valign="top">unordered_map&lt; pair&lt; <a class="el" href="structhandlegraph_1_1path__handle__t.html">path_handle_t</a>, bool &gt;, pair&lt; vector&lt; <a class="el" href="classvg_1_1Surjector.html#ad79d4e7acb0ed17759fd3e3301767b02">path_chunk_t</a> &gt;, vector&lt; pair&lt; <a class="el" href="structhandlegraph_1_1step__handle__t.html">step_handle_t</a>, <a class="el" href="structhandlegraph_1_1step__handle__t.html">step_handle_t</a> &gt; &gt; &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1Surjector.html#adc4dbb4ce6f48d755c91e4931028c6d8">extract_overlapping_paths</a> (const <a class="el" href="classhandlegraph_1_1PathPositionHandleGraph.html">PathPositionHandleGraph</a> *<a class="el" href="classvg_1_1Surjector.html#a118010284d37b604a7bcd7eb8dd13537">graph</a>, const <a class="el" href="classvg_1_1multipath__alignment__t.html">multipath_alignment_t</a> &amp;source, const unordered_set&lt; <a class="el" href="structhandlegraph_1_1path__handle__t.html">path_handle_t</a> &gt; &amp;surjection_paths, unordered_map&lt; pair&lt; <a class="el" href="structhandlegraph_1_1path__handle__t.html">path_handle_t</a>, bool &gt;, vector&lt; tuple&lt; size_t, size_t, int32_t &gt;&gt;&gt; &amp;connections_out) const</td></tr>
<tr class="memdesc:adc4dbb4ce6f48d755c91e4931028c6d8"><td class="mdescLeft">&#160;</td><td class="mdescRight">same semantics except for a multipath alignment  <a href="classvg_1_1Surjector.html#adc4dbb4ce6f48d755c91e4931028c6d8">More...</a><br /></td></tr>
<tr class="separator:adc4dbb4ce6f48d755c91e4931028c6d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa5bf36e4334688af92729d6ca4f6d112"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1Surjector.html#aa5bf36e4334688af92729d6ca4f6d112">filter_redundant_path_chunks</a> (vector&lt; <a class="el" href="classvg_1_1Surjector.html#ad79d4e7acb0ed17759fd3e3301767b02">path_chunk_t</a> &gt; &amp;path_chunks, vector&lt; pair&lt; <a class="el" href="structhandlegraph_1_1step__handle__t.html">step_handle_t</a>, <a class="el" href="structhandlegraph_1_1step__handle__t.html">step_handle_t</a> &gt;&gt; &amp;ref_chunks, vector&lt; tuple&lt; size_t, size_t, int32_t &gt;&gt; &amp;connections) const</td></tr>
<tr class="separator:aa5bf36e4334688af92729d6ca4f6d112"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af146dba8aa5b22978c94cfcf0fd643d1"><td class="memItemLeft" align="right" valign="top">pair&lt; size_t, size_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1Surjector.html#af146dba8aa5b22978c94cfcf0fd643d1">compute_path_interval</a> (const <a class="el" href="classhandlegraph_1_1PathPositionHandleGraph.html">PathPositionHandleGraph</a> *<a class="el" href="classvg_1_1Surjector.html#a118010284d37b604a7bcd7eb8dd13537">graph</a>, const <a class="el" href="structvg_1_1Alignment.html">Alignment</a> &amp;source, <a class="el" href="structhandlegraph_1_1path__handle__t.html">path_handle_t</a> path_handle, bool rev_strand, const vector&lt; <a class="el" href="classvg_1_1Surjector.html#ad79d4e7acb0ed17759fd3e3301767b02">path_chunk_t</a> &gt; &amp;path_chunks) const</td></tr>
<tr class="separator:af146dba8aa5b22978c94cfcf0fd643d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af05f461840ebac9a70156214c843ee39"><td class="memItemLeft" align="right" valign="top">unordered_map&lt; <a class="el" href="namespacevg.html#afaa15fd8bdfd688d48561e1b12aee821">id_t</a>, pair&lt; <a class="el" href="namespacevg.html#afaa15fd8bdfd688d48561e1b12aee821">id_t</a>, bool &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1Surjector.html#af05f461840ebac9a70156214c843ee39">extract_linearized_path_graph</a> (const <a class="el" href="classhandlegraph_1_1PathPositionHandleGraph.html">PathPositionHandleGraph</a> *<a class="el" href="classvg_1_1Surjector.html#a118010284d37b604a7bcd7eb8dd13537">graph</a>, <a class="el" href="classhandlegraph_1_1MutableHandleGraph.html">MutableHandleGraph</a> *into, <a class="el" href="structhandlegraph_1_1path__handle__t.html">path_handle_t</a> path_handle, size_t first, size_t last) const</td></tr>
<tr class="memdesc:af05f461840ebac9a70156214c843ee39"><td class="mdescLeft">&#160;</td><td class="mdescRight">make a linear graph that corresponds to a path interval, possibly duplicating nodes in case of cycles  <a href="classvg_1_1Surjector.html#af05f461840ebac9a70156214c843ee39">More...</a><br /></td></tr>
<tr class="separator:af05f461840ebac9a70156214c843ee39"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac4e7823cc2ce4b65bb8910ef2c1dcbee"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1Surjector.html#ac4e7823cc2ce4b65bb8910ef2c1dcbee">set_path_position</a> (const <a class="el" href="classhandlegraph_1_1PathPositionHandleGraph.html">PathPositionHandleGraph</a> *<a class="el" href="classvg_1_1Surjector.html#a118010284d37b604a7bcd7eb8dd13537">graph</a>, const <a class="el" href="namespacevg.html#a54512eefe4b0e14cb3b0057c23350240">pos_t</a> &amp;init_surj_pos, const <a class="el" href="namespacevg.html#a54512eefe4b0e14cb3b0057c23350240">pos_t</a> &amp;final_surj_pos, const <a class="el" href="structhandlegraph_1_1step__handle__t.html">step_handle_t</a> &amp;range_begin, const <a class="el" href="structhandlegraph_1_1step__handle__t.html">step_handle_t</a> &amp;range_end, bool rev_strand, string &amp;path_name_out, int64_t &amp;path_pos_out, bool &amp;path_rev_out) const</td></tr>
<tr class="memdesc:ac4e7823cc2ce4b65bb8910ef2c1dcbee"><td class="mdescLeft">&#160;</td><td class="mdescRight">use the graph position bounds and the path range bounds to assign a path position to a surjected read  <a href="classvg_1_1Surjector.html#ac4e7823cc2ce4b65bb8910ef2c1dcbee">More...</a><br /></td></tr>
<tr class="separator:ac4e7823cc2ce4b65bb8910ef2c1dcbee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a98ca84936638bdcb054e3304b6f959f1"><td class="memItemLeft" align="right" valign="top">vector&lt; vector&lt; size_t &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1Surjector.html#a98ca84936638bdcb054e3304b6f959f1">reverse_adjacencies</a> (const vector&lt; vector&lt; size_t &gt;&gt; &amp;adj) const</td></tr>
<tr class="memdesc:a98ca84936638bdcb054e3304b6f959f1"><td class="mdescLeft">&#160;</td><td class="mdescRight">reverses an adjacency list  <a href="classvg_1_1Surjector.html#a98ca84936638bdcb054e3304b6f959f1">More...</a><br /></td></tr>
<tr class="separator:a98ca84936638bdcb054e3304b6f959f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af7bc3c25f2466322fd6ffd67d66c6dfa"><td class="memItemLeft" align="right" valign="top">vector&lt; size_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1Surjector.html#af7bc3c25f2466322fd6ffd67d66c6dfa">connected_components</a> (const vector&lt; vector&lt; size_t &gt;&gt; &amp;adj, const vector&lt; vector&lt; size_t &gt;&gt; &amp;rev_adj, size_t *num_comps_out) const</td></tr>
<tr class="separator:af7bc3c25f2466322fd6ffd67d66c6dfa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2149d1e5e6aba2e07b92030e6afc617d"><td class="memItemLeft" align="right" valign="top">vector&lt; vector&lt; size_t &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1Surjector.html#a2149d1e5e6aba2e07b92030e6afc617d">transitive_reduction</a> (const vector&lt; vector&lt; size_t &gt;&gt; &amp;adj) const</td></tr>
<tr class="memdesc:a2149d1e5e6aba2e07b92030e6afc617d"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns the transitive reduction of a topologically sorted DAG's adjacency list  <a href="classvg_1_1Surjector.html#a2149d1e5e6aba2e07b92030e6afc617d">More...</a><br /></td></tr>
<tr class="separator:a2149d1e5e6aba2e07b92030e6afc617d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aafa4eb4d310ac530ed186170dc34dba9"><td class="memItemLeft" align="right" valign="top">vector&lt; vector&lt; size_t &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1Surjector.html#aafa4eb4d310ac530ed186170dc34dba9">remove_dominated_chunks</a> (const string &amp;src_sequence, const vector&lt; vector&lt; size_t &gt;&gt; &amp;adj, vector&lt; <a class="el" href="classvg_1_1Surjector.html#ad79d4e7acb0ed17759fd3e3301767b02">path_chunk_t</a> &gt; &amp;path_chunks, vector&lt; pair&lt; <a class="el" href="structhandlegraph_1_1step__handle__t.html">step_handle_t</a>, <a class="el" href="structhandlegraph_1_1step__handle__t.html">step_handle_t</a> &gt;&gt; &amp;ref_chunks, vector&lt; tuple&lt; size_t, size_t, int32_t &gt;&gt; &amp;connections) const</td></tr>
<tr class="memdesc:aafa4eb4d310ac530ed186170dc34dba9"><td class="mdescLeft">&#160;</td><td class="mdescRight">eliminate any path chunks that have the exact same colinearities as another but are much shorter  <a href="classvg_1_1Surjector.html#aafa4eb4d310ac530ed186170dc34dba9">More...</a><br /></td></tr>
<tr class="separator:aafa4eb4d310ac530ed186170dc34dba9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a057141cd5d1aabc6fbb977ab71446f6c"><td class="memItemLeft" align="right" valign="top">vector&lt; pair&lt; vector&lt; size_t &gt;, vector&lt; size_t &gt; &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1Surjector.html#a057141cd5d1aabc6fbb977ab71446f6c">find_constriction_bicliques</a> (const vector&lt; vector&lt; size_t &gt;&gt; &amp;adj, const string &amp;src_sequence, const vector&lt; <a class="el" href="classvg_1_1Surjector.html#ad79d4e7acb0ed17759fd3e3301767b02">path_chunk_t</a> &gt; &amp;path_chunks, const vector&lt; tuple&lt; size_t, size_t, int32_t &gt;&gt; &amp;connections) const</td></tr>
<tr class="separator:a057141cd5d1aabc6fbb977ab71446f6c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab65da876e448d86bc64985c0b14d3e78"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1Surjector.html#ab65da876e448d86bc64985c0b14d3e78">prune_unconnectable</a> (vector&lt; vector&lt; size_t &gt;&gt; &amp;adj, vector&lt; vector&lt; tuple&lt; size_t, int32_t, bool &gt;&gt;&gt; &amp;splice_adj, vector&lt; size_t &gt; &amp;component, vector&lt; vector&lt; size_t &gt;&gt; &amp;comp_groups, vector&lt; <a class="el" href="classvg_1_1Surjector.html#ad79d4e7acb0ed17759fd3e3301767b02">path_chunk_t</a> &gt; &amp;path_chunks, vector&lt; pair&lt; <a class="el" href="structhandlegraph_1_1step__handle__t.html">step_handle_t</a>, <a class="el" href="structhandlegraph_1_1step__handle__t.html">step_handle_t</a> &gt;&gt; &amp;ref_chunks) const</td></tr>
<tr class="separator:ab65da876e448d86bc64985c0b14d3e78"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pro_methods_classvg_1_1AlignerClient"><td colspan="2" onclick="javascript:toggleInherit('pro_methods_classvg_1_1AlignerClient')"><img src="closed.png" alt="-"/>&#160;Protected Member Functions inherited from <a class="el" href="classvg_1_1AlignerClient.html">vg::AlignerClient</a></td></tr>
<tr class="memitem:ab180631766b1e787e29dd202ad455d90 inherit pro_methods_classvg_1_1AlignerClient"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1AlignerClient.html#ab180631766b1e787e29dd202ad455d90">AlignerClient</a> (double <a class="el" href="classvg_1_1AlignerClient.html#a65428f092aaa5d894b709e247cf0121a">gc_content_estimate</a>=vg::default_gc_content)</td></tr>
<tr class="separator:ab180631766b1e787e29dd202ad455d90 inherit pro_methods_classvg_1_1AlignerClient"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a50649d9b2fc24254a8ac002486cd4dbb inherit pro_methods_classvg_1_1AlignerClient"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classvg_1_1GSSWAligner.html">GSSWAligner</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1AlignerClient.html#a50649d9b2fc24254a8ac002486cd4dbb">get_aligner</a> (bool have_qualities=true) const</td></tr>
<tr class="separator:a50649d9b2fc24254a8ac002486cd4dbb inherit pro_methods_classvg_1_1AlignerClient"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a79071998ffe8ea584e2b6c70487ceb67 inherit pro_methods_classvg_1_1AlignerClient"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classvg_1_1QualAdjAligner.html">QualAdjAligner</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1AlignerClient.html#a79071998ffe8ea584e2b6c70487ceb67">get_qual_adj_aligner</a> () const</td></tr>
<tr class="separator:a79071998ffe8ea584e2b6c70487ceb67 inherit pro_methods_classvg_1_1AlignerClient"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a981d1611f55817d7c375a5665666e408 inherit pro_methods_classvg_1_1AlignerClient"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classvg_1_1Aligner.html">Aligner</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1AlignerClient.html#a981d1611f55817d7c375a5665666e408">get_regular_aligner</a> () const</td></tr>
<tr class="separator:a981d1611f55817d7c375a5665666e408 inherit pro_methods_classvg_1_1AlignerClient"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-static-methods"></a>
Static Protected Member Functions</h2></td></tr>
<tr class="memitem:a139ffe849fc1164217e45ea5755fc518"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="structvg_1_1Alignment.html">Alignment</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1Surjector.html#a139ffe849fc1164217e45ea5755fc518">make_null_alignment</a> (const <a class="el" href="structvg_1_1Alignment.html">Alignment</a> &amp;source)</td></tr>
<tr class="memdesc:a139ffe849fc1164217e45ea5755fc518"><td class="mdescLeft">&#160;</td><td class="mdescRight">make a sentinel meant to indicate an unmapped read  <a href="classvg_1_1Surjector.html#a139ffe849fc1164217e45ea5755fc518">More...</a><br /></td></tr>
<tr class="separator:a139ffe849fc1164217e45ea5755fc518"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7db137631f3315ede2f6887334a161b4"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classvg_1_1multipath__alignment__t.html">multipath_alignment_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1Surjector.html#a7db137631f3315ede2f6887334a161b4">make_null_mp_alignment</a> (const string &amp;src_sequence, const string &amp;src_quality)</td></tr>
<tr class="separator:a7db137631f3315ede2f6887334a161b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-attribs"></a>
Protected Attributes</h2></td></tr>
<tr class="memitem:a118010284d37b604a7bcd7eb8dd13537"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classhandlegraph_1_1PathPositionHandleGraph.html">PathPositionHandleGraph</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1Surjector.html#a118010284d37b604a7bcd7eb8dd13537">graph</a> = nullptr</td></tr>
<tr class="memdesc:a118010284d37b604a7bcd7eb8dd13537"><td class="mdescLeft">&#160;</td><td class="mdescRight">the graph we're surjecting onto  <a href="classvg_1_1Surjector.html#a118010284d37b604a7bcd7eb8dd13537">More...</a><br /></td></tr>
<tr class="separator:a118010284d37b604a7bcd7eb8dd13537"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="inherited"></a>
Additional Inherited Members</h2></td></tr>
<tr class="inherit_header pub_static_methods_classvg_1_1AlignerClient"><td colspan="2" onclick="javascript:toggleInherit('pub_static_methods_classvg_1_1AlignerClient')"><img src="closed.png" alt="-"/>&#160;Static Public Member Functions inherited from <a class="el" href="classvg_1_1AlignerClient.html">vg::AlignerClient</a></td></tr>
<tr class="memitem:afe30f7cbea293a0fe369c21e22bf7881 inherit pub_static_methods_classvg_1_1AlignerClient"><td class="memItemLeft" align="right" valign="top">static int8_t *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1AlignerClient.html#afe30f7cbea293a0fe369c21e22bf7881">parse_matrix</a> (std::istream &amp;matrix_stream)</td></tr>
<tr class="memdesc:afe30f7cbea293a0fe369c21e22bf7881 inherit pub_static_methods_classvg_1_1AlignerClient"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocates an array to hold a 4x4 substitution matrix and returns it.  <a href="classvg_1_1AlignerClient.html#afe30f7cbea293a0fe369c21e22bf7881">More...</a><br /></td></tr>
<tr class="separator:afe30f7cbea293a0fe369c21e22bf7881 inherit pub_static_methods_classvg_1_1AlignerClient"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Member Typedef Documentation</h2>
<a id="ad79d4e7acb0ed17759fd3e3301767b02"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad79d4e7acb0ed17759fd3e3301767b02">&#9670;&nbsp;</a></span>path_chunk_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classvg_1_1Surjector.html#ad79d4e7acb0ed17759fd3e3301767b02">vg::Surjector::path_chunk_t</a> =  pair&lt;pair&lt;string::const_iterator, string::const_iterator&gt;, <a class="el" href="structvg_1_1Path.html">Path</a>&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>a local type that represents a read interval matched to a portion of the alignment path </p>

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a4b083231c3ae02e3e14c3efb2a72eb1d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4b083231c3ae02e3e14c3efb2a72eb1d">&#9670;&nbsp;</a></span>Surjector()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">vg::Surjector::Surjector </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classhandlegraph_1_1PathPositionHandleGraph.html">PathPositionHandleGraph</a> *&#160;</td>
          <td class="paramname"><em>graph</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="af146dba8aa5b22978c94cfcf0fd643d1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af146dba8aa5b22978c94cfcf0fd643d1">&#9670;&nbsp;</a></span>compute_path_interval()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">pair&lt; size_t, size_t &gt; vg::Surjector::compute_path_interval </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classhandlegraph_1_1PathPositionHandleGraph.html">PathPositionHandleGraph</a> *&#160;</td>
          <td class="paramname"><em>graph</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structvg_1_1Alignment.html">Alignment</a> &amp;&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structhandlegraph_1_1path__handle__t.html">path_handle_t</a>&#160;</td>
          <td class="paramname"><em>path_handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>rev_strand</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const vector&lt; <a class="el" href="classvg_1_1Surjector.html#ad79d4e7acb0ed17759fd3e3301767b02">path_chunk_t</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>path_chunks</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Compute the widest end-inclusive interval of path positions that the realigned sequence could align to, or an interval where start &gt; end if there are no path chunks. </p>

</div>
</div>
<a id="af7bc3c25f2466322fd6ffd67d66c6dfa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af7bc3c25f2466322fd6ffd67d66c6dfa">&#9670;&nbsp;</a></span>connected_components()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">vector&lt; size_t &gt; vg::Surjector::connected_components </td>
          <td>(</td>
          <td class="paramtype">const vector&lt; vector&lt; size_t &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>adj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const vector&lt; vector&lt; size_t &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>rev_adj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t *&#160;</td>
          <td class="paramname"><em>num_comps_out</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>returns a vector assignming each node to a connectd component, requires both the forward and reverse adjacency lists. optionally also returns the total number of components </p>

</div>
</div>
<a id="af05f461840ebac9a70156214c843ee39"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af05f461840ebac9a70156214c843ee39">&#9670;&nbsp;</a></span>extract_linearized_path_graph()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unordered_map&lt; <a class="el" href="namespacevg.html#afaa15fd8bdfd688d48561e1b12aee821">id_t</a>, pair&lt; <a class="el" href="namespacevg.html#afaa15fd8bdfd688d48561e1b12aee821">id_t</a>, bool &gt; &gt; vg::Surjector::extract_linearized_path_graph </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classhandlegraph_1_1PathPositionHandleGraph.html">PathPositionHandleGraph</a> *&#160;</td>
          <td class="paramname"><em>graph</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classhandlegraph_1_1MutableHandleGraph.html">MutableHandleGraph</a> *&#160;</td>
          <td class="paramname"><em>into</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structhandlegraph_1_1path__handle__t.html">path_handle_t</a>&#160;</td>
          <td class="paramname"><em>path_handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>last</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>make a linear graph that corresponds to a path interval, possibly duplicating nodes in case of cycles </p>

</div>
</div>
<a id="af4b7099431a6a5334141760cc8922281"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af4b7099431a6a5334141760cc8922281">&#9670;&nbsp;</a></span>extract_overlapping_paths() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unordered_map&lt; pair&lt; <a class="el" href="structhandlegraph_1_1path__handle__t.html">path_handle_t</a>, bool &gt;, pair&lt; vector&lt; <a class="el" href="classvg_1_1Surjector.html#ad79d4e7acb0ed17759fd3e3301767b02">Surjector::path_chunk_t</a> &gt;, vector&lt; pair&lt; <a class="el" href="structhandlegraph_1_1step__handle__t.html">step_handle_t</a>, <a class="el" href="structhandlegraph_1_1step__handle__t.html">step_handle_t</a> &gt; &gt; &gt; &gt; vg::Surjector::extract_overlapping_paths </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classhandlegraph_1_1PathPositionHandleGraph.html">PathPositionHandleGraph</a> *&#160;</td>
          <td class="paramname"><em>graph</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structvg_1_1Alignment.html">Alignment</a> &amp;&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unordered_set&lt; <a class="el" href="structhandlegraph_1_1path__handle__t.html">path_handle_t</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>surjection_paths</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>get the chunks of the alignment path that follow the given reference paths </p>

</div>
</div>
<a id="adc4dbb4ce6f48d755c91e4931028c6d8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adc4dbb4ce6f48d755c91e4931028c6d8">&#9670;&nbsp;</a></span>extract_overlapping_paths() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unordered_map&lt; pair&lt; <a class="el" href="structhandlegraph_1_1path__handle__t.html">path_handle_t</a>, bool &gt;, pair&lt; vector&lt; <a class="el" href="classvg_1_1Surjector.html#ad79d4e7acb0ed17759fd3e3301767b02">Surjector::path_chunk_t</a> &gt;, vector&lt; pair&lt; <a class="el" href="structhandlegraph_1_1step__handle__t.html">step_handle_t</a>, <a class="el" href="structhandlegraph_1_1step__handle__t.html">step_handle_t</a> &gt; &gt; &gt; &gt; vg::Surjector::extract_overlapping_paths </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classhandlegraph_1_1PathPositionHandleGraph.html">PathPositionHandleGraph</a> *&#160;</td>
          <td class="paramname"><em>graph</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classvg_1_1multipath__alignment__t.html">multipath_alignment_t</a> &amp;&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unordered_set&lt; <a class="el" href="structhandlegraph_1_1path__handle__t.html">path_handle_t</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>surjection_paths</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unordered_map&lt; pair&lt; <a class="el" href="structhandlegraph_1_1path__handle__t.html">path_handle_t</a>, bool &gt;, vector&lt; tuple&lt; size_t, size_t, int32_t &gt;&gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>connections_out</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>same semantics except for a multipath alignment </p>

</div>
</div>
<a id="aa5bf36e4334688af92729d6ca4f6d112"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa5bf36e4334688af92729d6ca4f6d112">&#9670;&nbsp;</a></span>filter_redundant_path_chunks()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void vg::Surjector::filter_redundant_path_chunks </td>
          <td>(</td>
          <td class="paramtype">vector&lt; <a class="el" href="classvg_1_1Surjector.html#ad79d4e7acb0ed17759fd3e3301767b02">path_chunk_t</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>path_chunks</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector&lt; pair&lt; <a class="el" href="structhandlegraph_1_1step__handle__t.html">step_handle_t</a>, <a class="el" href="structhandlegraph_1_1step__handle__t.html">step_handle_t</a> &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>ref_chunks</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector&lt; tuple&lt; size_t, size_t, int32_t &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>connections</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>remove any path chunks and corresponding ref chunks that are identical to a longer path chunk over the region where they overlap </p>

</div>
</div>
<a id="a057141cd5d1aabc6fbb977ab71446f6c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a057141cd5d1aabc6fbb977ab71446f6c">&#9670;&nbsp;</a></span>find_constriction_bicliques()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">vector&lt; pair&lt; vector&lt; size_t &gt;, vector&lt; size_t &gt; &gt; &gt; vg::Surjector::find_constriction_bicliques </td>
          <td>(</td>
          <td class="paramtype">const vector&lt; vector&lt; size_t &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>adj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const string &amp;&#160;</td>
          <td class="paramname"><em>src_sequence</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const vector&lt; <a class="el" href="classvg_1_1Surjector.html#ad79d4e7acb0ed17759fd3e3301767b02">path_chunk_t</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>path_chunks</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const vector&lt; tuple&lt; size_t, size_t, int32_t &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>connections</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>returns all sets of chunks such that 1) all of chunks on the left set abut all of the chunks on the right set on the read, 2) all source-to-sink paths in the connected component go through an edge between the left and right sides, 3) all of the chunks that do not have a connection between them are fully connected (i.e. form a biclique) </p>

</div>
</div>
<a id="a139ffe849fc1164217e45ea5755fc518"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a139ffe849fc1164217e45ea5755fc518">&#9670;&nbsp;</a></span>make_null_alignment()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structvg_1_1Alignment.html">Alignment</a> vg::Surjector::make_null_alignment </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structvg_1_1Alignment.html">Alignment</a> &amp;&#160;</td>
          <td class="paramname"><em>source</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>make a sentinel meant to indicate an unmapped read </p>

</div>
</div>
<a id="a7db137631f3315ede2f6887334a161b4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7db137631f3315ede2f6887334a161b4">&#9670;&nbsp;</a></span>make_null_mp_alignment()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvg_1_1multipath__alignment__t.html">multipath_alignment_t</a> vg::Surjector::make_null_mp_alignment </td>
          <td>(</td>
          <td class="paramtype">const string &amp;&#160;</td>
          <td class="paramname"><em>src_sequence</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const string &amp;&#160;</td>
          <td class="paramname"><em>src_quality</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ab65da876e448d86bc64985c0b14d3e78"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab65da876e448d86bc64985c0b14d3e78">&#9670;&nbsp;</a></span>prune_unconnectable()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void vg::Surjector::prune_unconnectable </td>
          <td>(</td>
          <td class="paramtype">vector&lt; vector&lt; size_t &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>adj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector&lt; vector&lt; tuple&lt; size_t, int32_t, bool &gt;&gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>splice_adj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector&lt; size_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>component</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector&lt; vector&lt; size_t &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>comp_groups</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector&lt; <a class="el" href="classvg_1_1Surjector.html#ad79d4e7acb0ed17759fd3e3301767b02">path_chunk_t</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>path_chunks</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector&lt; pair&lt; <a class="el" href="structhandlegraph_1_1step__handle__t.html">step_handle_t</a>, <a class="el" href="structhandlegraph_1_1step__handle__t.html">step_handle_t</a> &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>ref_chunks</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a14e1e1e6e00de6609e6c95826f53f3e3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a14e1e1e6e00de6609e6c95826f53f3e3">&#9670;&nbsp;</a></span>realigning_surject()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structvg_1_1Alignment.html">Alignment</a> vg::Surjector::realigning_surject </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classhandlegraph_1_1PathPositionHandleGraph.html">PathPositionHandleGraph</a> *&#160;</td>
          <td class="paramname"><em>graph</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structvg_1_1Alignment.html">Alignment</a> &amp;&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structhandlegraph_1_1path__handle__t.html">path_handle_t</a> &amp;&#160;</td>
          <td class="paramname"><em>path_handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>rev_strand</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const vector&lt; <a class="el" href="classvg_1_1Surjector.html#ad79d4e7acb0ed17759fd3e3301767b02">path_chunk_t</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>path_chunks</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">pair&lt; <a class="el" href="structhandlegraph_1_1step__handle__t.html">step_handle_t</a>, <a class="el" href="structhandlegraph_1_1step__handle__t.html">step_handle_t</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>path_range_out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>allow_negative_scores</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>preserve_N_alignments</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>preserve_tail_indel_anchors</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="aafa4eb4d310ac530ed186170dc34dba9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aafa4eb4d310ac530ed186170dc34dba9">&#9670;&nbsp;</a></span>remove_dominated_chunks()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">vector&lt; vector&lt; size_t &gt; &gt; vg::Surjector::remove_dominated_chunks </td>
          <td>(</td>
          <td class="paramtype">const string &amp;&#160;</td>
          <td class="paramname"><em>src_sequence</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const vector&lt; vector&lt; size_t &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>adj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector&lt; <a class="el" href="classvg_1_1Surjector.html#ad79d4e7acb0ed17759fd3e3301767b02">path_chunk_t</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>path_chunks</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector&lt; pair&lt; <a class="el" href="structhandlegraph_1_1step__handle__t.html">step_handle_t</a>, <a class="el" href="structhandlegraph_1_1step__handle__t.html">step_handle_t</a> &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>ref_chunks</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector&lt; tuple&lt; size_t, size_t, int32_t &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>connections</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>eliminate any path chunks that have the exact same colinearities as another but are much shorter </p>

</div>
</div>
<a id="a98ca84936638bdcb054e3304b6f959f1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a98ca84936638bdcb054e3304b6f959f1">&#9670;&nbsp;</a></span>reverse_adjacencies()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">vector&lt; vector&lt; size_t &gt; &gt; vg::Surjector::reverse_adjacencies </td>
          <td>(</td>
          <td class="paramtype">const vector&lt; vector&lt; size_t &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>adj</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>reverses an adjacency list </p>

</div>
</div>
<a id="ac4e7823cc2ce4b65bb8910ef2c1dcbee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac4e7823cc2ce4b65bb8910ef2c1dcbee">&#9670;&nbsp;</a></span>set_path_position()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void vg::Surjector::set_path_position </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classhandlegraph_1_1PathPositionHandleGraph.html">PathPositionHandleGraph</a> *&#160;</td>
          <td class="paramname"><em>graph</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacevg.html#a54512eefe4b0e14cb3b0057c23350240">pos_t</a> &amp;&#160;</td>
          <td class="paramname"><em>init_surj_pos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacevg.html#a54512eefe4b0e14cb3b0057c23350240">pos_t</a> &amp;&#160;</td>
          <td class="paramname"><em>final_surj_pos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structhandlegraph_1_1step__handle__t.html">step_handle_t</a> &amp;&#160;</td>
          <td class="paramname"><em>range_begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structhandlegraph_1_1step__handle__t.html">step_handle_t</a> &amp;&#160;</td>
          <td class="paramname"><em>range_end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>rev_strand</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">string &amp;&#160;</td>
          <td class="paramname"><em>path_name_out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t &amp;&#160;</td>
          <td class="paramname"><em>path_pos_out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool &amp;&#160;</td>
          <td class="paramname"><em>path_rev_out</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>use the graph position bounds and the path range bounds to assign a path position to a surjected read </p>

</div>
</div>
<a id="a8418e7a55b6b53456c80cbcf937406b5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8418e7a55b6b53456c80cbcf937406b5">&#9670;&nbsp;</a></span>spliced_surject()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvg_1_1multipath__alignment__t.html">multipath_alignment_t</a> vg::Surjector::spliced_surject </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classhandlegraph_1_1PathPositionHandleGraph.html">PathPositionHandleGraph</a> *&#160;</td>
          <td class="paramname"><em>path_position_graph</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const string &amp;&#160;</td>
          <td class="paramname"><em>src_sequence</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const string &amp;&#160;</td>
          <td class="paramname"><em>src_quality</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int32_t&#160;</td>
          <td class="paramname"><em>src_mapping_quality</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structhandlegraph_1_1path__handle__t.html">path_handle_t</a> &amp;&#160;</td>
          <td class="paramname"><em>path_handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>rev_strand</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector&lt; <a class="el" href="classvg_1_1Surjector.html#ad79d4e7acb0ed17759fd3e3301767b02">path_chunk_t</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>path_chunks</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector&lt; pair&lt; <a class="el" href="structhandlegraph_1_1step__handle__t.html">step_handle_t</a>, <a class="el" href="structhandlegraph_1_1step__handle__t.html">step_handle_t</a> &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>ref_chunks</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector&lt; tuple&lt; size_t, size_t, int32_t &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>connections</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">pair&lt; <a class="el" href="structhandlegraph_1_1step__handle__t.html">step_handle_t</a>, <a class="el" href="structhandlegraph_1_1step__handle__t.html">step_handle_t</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>path_range_out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>allow_negative_scores</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>deletions_as_splices</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a265cf90a6fb12021a70b87ec647c0867"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a265cf90a6fb12021a70b87ec647c0867">&#9670;&nbsp;</a></span>surject() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structvg_1_1Alignment.html">Alignment</a> vg::Surjector::surject </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structvg_1_1Alignment.html">Alignment</a> &amp;&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unordered_set&lt; <a class="el" href="structhandlegraph_1_1path__handle__t.html">path_handle_t</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>paths</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>allow_negative_scores</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>preserve_deletions</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Extract the portions of an alignment that are on a chosen set of paths and try to align realign the portions that are off of the chosen paths to the intervening path segments to obtain an alignment that is fully restricted to the paths.</p>
<p>Replaces the alignment's refpos with the path name, position, and strand the alignment has been surjected to.</p>
<p>Optionally either allow softclips so that the alignment has a nonnegative score on the path or require the full-length alignment, possibly creating a negative score.</p>
<p>Also optionally leaves deletions against the reference path in the final alignment (useful for splicing). </p>

</div>
</div>
<a id="a4e4e4c28b1313850e647f4d258a0ea82"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4e4e4c28b1313850e647f4d258a0ea82">&#9670;&nbsp;</a></span>surject() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structvg_1_1Alignment.html">Alignment</a> vg::Surjector::surject </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structvg_1_1Alignment.html">Alignment</a> &amp;&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unordered_set&lt; <a class="el" href="structhandlegraph_1_1path__handle__t.html">path_handle_t</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>paths</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">string &amp;&#160;</td>
          <td class="paramname"><em>path_name_out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t &amp;&#160;</td>
          <td class="paramname"><em>path_pos_out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool &amp;&#160;</td>
          <td class="paramname"><em>path_rev_out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>allow_negative_scores</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>preserve_deletions</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Extract the portions of an alignment that are on a chosen set of paths and try to align realign the portions that are off of the chosen paths to the intervening path segments to obtain an alignment that is fully restricted to the paths.</p>
<p>Also returns the path name, position, and strand of the new alignment.</p>
<p>Optionally either allow softclips so that the alignment has a nonnegative score on the path or require the full-length alignment, possibly creating a negative score.</p>
<p>Also optionally leaves deletions against the reference path in the final alignment (useful for splicing). </p>

</div>
</div>
<a id="a80afa331fde9e8bcff66c4e87400217a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a80afa331fde9e8bcff66c4e87400217a">&#9670;&nbsp;</a></span>surject() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvg_1_1multipath__alignment__t.html">multipath_alignment_t</a> vg::Surjector::surject </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classvg_1_1multipath__alignment__t.html">multipath_alignment_t</a> &amp;&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unordered_set&lt; <a class="el" href="structhandlegraph_1_1path__handle__t.html">path_handle_t</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>paths</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">string &amp;&#160;</td>
          <td class="paramname"><em>path_name_out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t &amp;&#160;</td>
          <td class="paramname"><em>path_pos_out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool &amp;&#160;</td>
          <td class="paramname"><em>path_rev_out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>allow_negative_scores</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>preserve_deletions</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Same semantics as with alignments except that connections are always preserved as splices. The output consists of a multipath alignment with a single path, separated by splices (either from large deletions or from connections) </p>

</div>
</div>
<a id="ae96dd1321ff616a23b471e069e8597ea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae96dd1321ff616a23b471e069e8597ea">&#9670;&nbsp;</a></span>surject_internal()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void vg::Surjector::surject_internal </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structvg_1_1Alignment.html">Alignment</a> *&#160;</td>
          <td class="paramname"><em>source_aln</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classvg_1_1multipath__alignment__t.html">multipath_alignment_t</a> *&#160;</td>
          <td class="paramname"><em>source_mp_aln</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structvg_1_1Alignment.html">Alignment</a> *&#160;</td>
          <td class="paramname"><em>aln_out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classvg_1_1multipath__alignment__t.html">multipath_alignment_t</a> *&#160;</td>
          <td class="paramname"><em>mp_aln_out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unordered_set&lt; <a class="el" href="structhandlegraph_1_1path__handle__t.html">path_handle_t</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>paths</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">string &amp;&#160;</td>
          <td class="paramname"><em>path_name_out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t &amp;&#160;</td>
          <td class="paramname"><em>path_pos_out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool &amp;&#160;</td>
          <td class="paramname"><em>path_rev_out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>allow_negative_scores</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>preserve_deletions</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a2149d1e5e6aba2e07b92030e6afc617d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2149d1e5e6aba2e07b92030e6afc617d">&#9670;&nbsp;</a></span>transitive_reduction()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">vector&lt; vector&lt; size_t &gt; &gt; vg::Surjector::transitive_reduction </td>
          <td>(</td>
          <td class="paramtype">const vector&lt; vector&lt; size_t &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>adj</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>returns the transitive reduction of a topologically sorted DAG's adjacency list </p>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="ace7092128b309c97f00fc688d3311c14"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ace7092128b309c97f00fc688d3311c14">&#9670;&nbsp;</a></span>dominated_path_chunk_diff</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int64_t vg::Surjector::dominated_path_chunk_diff = 10</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a118010284d37b604a7bcd7eb8dd13537"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a118010284d37b604a7bcd7eb8dd13537">&#9670;&nbsp;</a></span>graph</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classhandlegraph_1_1PathPositionHandleGraph.html">PathPositionHandleGraph</a>* vg::Surjector::graph = nullptr</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>the graph we're surjecting onto </p>

</div>
</div>
<a id="a1df336db06fea7951c960f71265d513d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1df336db06fea7951c960f71265d513d">&#9670;&nbsp;</a></span>low_complexity_p_value</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double vg::Surjector::low_complexity_p_value = .001</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a77d7a865fffb0ebbc979ba8139f026c5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a77d7a865fffb0ebbc979ba8139f026c5">&#9670;&nbsp;</a></span>max_subgraph_bases</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t vg::Surjector::max_subgraph_bases = 100 * 1024</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>How big of a graph in bp should we ever try to align against for realigning surjection? </p>

</div>
</div>
<a id="a59034e11562bb0969c25defd215f166b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a59034e11562bb0969c25defd215f166b">&#9670;&nbsp;</a></span>max_tail_anchor_prune</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int64_t vg::Surjector::max_tail_anchor_prune = 4</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a9046bb2c7267f996a6636518e2747b89"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9046bb2c7267f996a6636518e2747b89">&#9670;&nbsp;</a></span>min_splice_length</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int64_t vg::Surjector::min_splice_length = 20</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>the minimum length deletion that the spliced algorithm will interpret as a splice event </p>

</div>
</div>
<a id="af01db9677cefc7952fee698f8ee2b672"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af01db9677cefc7952fee698f8ee2b672">&#9670;&nbsp;</a></span>prune_suspicious_anchors</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool vg::Surjector::prune_suspicious_anchors = false</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="affb3a5676516b7042d5c2d08734ea3c8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#affb3a5676516b7042d5c2d08734ea3c8">&#9670;&nbsp;</a></span>warned_about_subgraph_size</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">atomic_flag vg::Surjector::warned_about_subgraph_size = ATOMIC_FLAG_INIT</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">mutable</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>And have we complained about hitting it? </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>src/<a class="el" href="surjector_8hpp.html">surjector.hpp</a></li>
<li>src/<a class="el" href="surjector_8cpp.html">surjector.cpp</a></li>
</ul>
</div><!-- contents -->
<!-- HTML footer for doxygen 1.8.9.1-->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.17
</small></address>
</body>
</html>
